# A0130684H
###### /src/Command/Add.java
``` java

import Parser.*;
import Task.*;

import java.util.ArrayList;
import java.util.Date;
import java.util.TreeMap;

import GUI.UI_TAB;


public class Add extends Command {
	private static final String MESSAGE_INVALID_ADD = "Please enter a valid add command.";
	private static final String MESSAGE_SUCCESSFUL_ADD = "Task \"%1$s\" is added to %2$s.";

	public Add(CommandUtils cu, ArrayList<Task> floatingTasks, ArrayList<Task> ongoingTasks,
			ArrayList<Task> completedTasks, ArrayList<Task> overdueTasks, ArrayList<Task> results, TreeMap<String, Category> categories) {
		super(cu, floatingTasks, ongoingTasks, completedTasks, overdueTasks, results, categories);
	}

	@Override
	public String execute() {
		TASK_TYPE type = cu.getType();
		switch (type) {
		case FLOATING:
			return addFloatingTasks();
		case DEADLINED:
			return addDeadlinedTasks();
		case EVENT:
			return addEvent();
		default:
			return MESSAGE_INVALID_ADD;
		}
	}

	private String addFloatingTasks() {
		String name = cu.getName();
		ArrayList<String> tags = cu.getTag();
		boolean important = cu.getImportance();
		System.out.println("====ADD==== tags: " + tags);
		System.out.println("====ADD==== size of arraylist: " + tags.size());
		
		Task task = new Task(name);
		task.setFlag(important);
		if (tags!=null) {
			for (String tagString: tags) {
				System.out.println("====ADD==== tag: " + tagString);
				if (tagString!=null) this.tagTask(tagString, task);
			}
		}

		this.floatingTasks.add(task);
		this.UIStatus = UI_TAB.FLOATING;
		this.lastModifiedIndex = this.floatingTasks.size()-1;

		System.out.println("=====add===== tasks: " + task.getCategories());
		return String.format(MESSAGE_SUCCESSFUL_ADD, task, this.UIStatus);
	}

	private String addDeadlinedTasks() {
		String name = cu.getName();
		ArrayList<String> tags = cu.getTag();
		Date endDateTime = cu.getEndTime();
		boolean important = cu.getImportance();
		System.out.println("====ADD==== tags: " + tags);

		Task task = new Task(name, endDateTime);
		task.setFlag(important);
		if (tags!=null) {
			for (String tagString: tags) {
				if (tagString!=null) this.tagTask(tagString, task);
			}
		}

		checkOverdueTask(task);
		return String.format(MESSAGE_SUCCESSFUL_ADD, task, this.UIStatus);
	}

	private String addEvent() {
		String name = cu.getName();
		ArrayList<String> tags = cu.getTag();
		Date startDateTime = cu.getStartTime();
		Date endDateTime = cu.getEndTime();
		boolean important = cu.getImportance();

		if (startDateTime.after(endDateTime)) {
			return MESSAGE_INVALID_EVENT_TIME;
		}

		Task task = new Task(name, startDateTime, endDateTime);
		task.setFlag(important);
		if (tags!=null) {
			for (String tagString: tags) {
				if (tagString!=null) this.tagTask(tagString, task);
			}
		}

		checkOverdueTask(task);	
		return String.format(MESSAGE_SUCCESSFUL_ADD, task, this.UIStatus);
	}

	private void checkOverdueTask(Task task) {
		if (task.getStatus()==TASK_STATUS.OVERDUE) {
			overdueTasks.add(task);
			this.UIStatus = UI_TAB.OVERDUE;
			this.lastModifiedIndex = this.overdueTasks.size()-1;
		}
		else if (task.getStatus()==TASK_STATUS.ONGOING) {
			ongoingTasks.add(task);
			this.UIStatus = UI_TAB.ONGOING;
			this.lastModifiedIndex = this.ongoingTasks.size()-1;
		}
	}
}
```
###### /src/Command/Command.java
``` java

import java.util.*;
import GUI.*;
import Parser.*;
import Task.*; 

public abstract class Command {
	protected static final int INDEX_ADJUSTMENT = 1;
	protected static final String MESSAGE_INVALID_START_TIME = "Please enter a valid start time of the event.";
	protected static final String MESSAGE_INVALID_END_TIME = "Please enter a valid end time of the task.";
	protected static final String MESSAGE_INVALID_EVENT_TIME = "Please enter a valid start and end time of the event.";
	protected static final String MESSAGE_INDEXOUTOFBOUND = "Please enter a valid index.";
	protected static final String MESSAGE_EMPTY_LIST = "There is no task in this tab. Please add more tasks.";
	protected static final String MESSAGE_UNSUCCESSFUL_SEARCH_TAG = "There is no tag named \"%1$s\".";

	protected UI_TAB UIStatus;
	protected CommandUtils cu;
	protected ArrayList<Task> ongoingTasks;
	protected ArrayList<Task> completedTasks;
	protected ArrayList<Task> overdueTasks;
	protected ArrayList<Task> floatingTasks;
	protected ArrayList<Task> results;
	protected TreeMap<String, Category> categories;
	protected int lastModifiedIndex;
	
	/**
	 * This method constructs an instance of Command.
	 * @param cu
	 * @param floatingTasks
	 * @param ongoingTasks
	 * @param completedTasks
	 * @param overdueTasks
	 * @param results
	 * @param categories
	 */
	public Command(CommandUtils cu, ArrayList<Task> floatingTasks, ArrayList<Task> ongoingTasks,
			ArrayList<Task> completedTasks, ArrayList<Task> overdueTasks, ArrayList<Task> results, TreeMap<String, Category> categories) {
		this.UIStatus = UIRightBox.getCurrentTab();
		this.cu = cu;
		this.floatingTasks = floatingTasks;
		this.ongoingTasks = ongoingTasks;
		this.completedTasks = completedTasks;
		this.overdueTasks = overdueTasks;
		this.results = results;
		this.categories = categories;
	}
	
	/**
	 * This method executes a user input and updates its memeory.
	 * @return {@code String feedback}
	 */
	public abstract String execute();

	/*******************************************ACCESSOR*********************************************/

	public TreeMap<String, Category> getCategories() {
		return this.categories;
	}

	public UI_TAB getStatus() {
		return this.UIStatus;
	}
	
	public int getLastModifiedIndex() {
		return this.lastModifiedIndex;
	}

	/******************************************INHERIENT METHODS*************************************/
	protected ArrayList<Task> retrieve(UI_TAB status) {
		switch (status) {
		case ONGOING:
			return this.ongoingTasks;
		case FLOATING:
			return this.floatingTasks;
		case COMPLETED:
			return this.completedTasks;
		case OVERDUE:
			return this.overdueTasks;
		case SEARCH:
			return this.results;
		case ALL:
			return combine(overdueTasks, ongoingTasks, floatingTasks, completedTasks);
		default:
			return null;
		}
	}

	protected void deleteTaskFromOtherTab(Task taskToDelete) {
		TASK_STATUS status = taskToDelete.getStatus();
		switch (status) {
		case ONGOING:
			this.ongoingTasks.remove(taskToDelete);
			break;
		case FLOATING:
			this.floatingTasks.remove(taskToDelete);
			break;
		case COMPLETED:
			this.completedTasks.remove(taskToDelete);
			break;
		case OVERDUE:
			this.overdueTasks.remove(taskToDelete);
			break;
		}
	}

	/*************************************CATEGORY MANIPULATION********************************/
	protected Category findCategory(String categoryString) {
		Category category = this.categories.get(categoryString.toLowerCase());
		return category;
	}


	// add task into category
	protected boolean tagTask(String categoryStr, Task task) {
		Category category = this.categories.get(categoryStr.toLowerCase());
		if (category==null) {
			category = new Category(categoryStr);
			this.categories.put(categoryStr.toLowerCase(), category);
		}
		boolean flag = category.addTask(task);
		System.out.println("[DEBUG Command/tagTask] category has " + flag + " been added to this task.");
		return flag;
	}

	//delete an entire category
	protected boolean deleteCategory(String categoryString) {
		Category category = this.categories.get(categoryString.toLowerCase());
		if (category==null) {
			return false;
		}
		ArrayList<Task> taggedTasks = category.getTasks();
		for (Task task: taggedTasks) {
			boolean indicator = task.deleteCategory(category.getName());
			if (indicator==false) {
				throw new Error("IMPOSSIBLE, this tag must have been added to this task previously.");
			}
		}
		this.categories.remove(categoryString.toLowerCase());
		return true;
	}

	//edit an entire category
	protected boolean editCategory(String oldTag, String newTag) {
		Category category = this.categories.get(oldTag.toLowerCase());
		if (category==null) {
			return false;
		}
		
		category.setName(newTag);
		ArrayList<Task> taggedTasks = category.getTasks();
		for (Task task: taggedTasks) {
			boolean indicator = task.deleteCategory(oldTag);
			if (indicator==false) {
				throw new Error("IMPOSSIBLE, this tag must have been added to this task previously.");
			}
			task.addCategory(newTag);
		}
		
		this.categories.remove(oldTag.toLowerCase());
		this.categories.put(newTag.toLowerCase(), category);
		return true;
	}

	// this method detaches reference of all categories under this task from this taskd
	protected boolean deleteTaskInCategory(Task task) {
		ArrayList<String> categoriesString = task.getCategories();
		for (String categoryString: categoriesString) {
			Category category = this.categories.get(categoryString.toLowerCase());
			boolean flag = category.deleteTask(task);
			if (flag==false) {
				throw new Error("IMPOSSIBLE, this tag must have been added to this task previously.");
			}
			if (category.getTasks().size()==0) {
				deleteCategory(categoryString);
			}
		}
		return true;
	}

	/*****************************************PRIVATE METHODS***************************************/
	
	private ArrayList<Task> combine(ArrayList<Task> overdueTasks, ArrayList<Task> ongoingTasks,
			ArrayList<Task> floatingTasks, ArrayList<Task> completedTasks) {
		ArrayList<Task> all = new ArrayList<Task>();
		all.addAll(overdueTasks);
		all.addAll(ongoingTasks);
		all.addAll(floatingTasks);
		all.addAll(completedTasks);
		return all;
	}
}
```
###### /src/Command/COMMAND_TYPE.java
``` java

public enum COMMAND_TYPE {
	ADD, DELETE, EDIT, UNDO, REDO, SEARCH, COMPLETE, TAG, UNTAG, FLAG, UNFLAG, SORT, 
	HELP, EXIT, CHANGE_DIRECTORY, INVALID;
}
```
###### /src/Command/Complete.java
``` java

import java.util.ArrayList;
import java.util.TreeMap;

import org.ocpsoft.prettytime.shade.edu.emory.mathcs.backport.java.util.Collections;

import GUI.UI_TAB;
import Parser.*;
import Task.*;

public class Complete extends Command {
	private static final String MESSAGE_INVALID_COMPLETE = "Please enter a valid complete command.";
	private static final String MESSAGE_SUCCESSFUL_COMPLETE = 
			"Congratulation! Task(s) at \"%1$s\" is/are successfully completed. ";
	private static final String MESSAGE_UNSUCCESSFUL_COMPLETE = 
			"Task(s) at \"%1$s\" failed to complete due to its/their invalid index or already completed status. ";

	public Complete(CommandUtils cu, ArrayList<Task> floatingTasks, ArrayList<Task> ongoingTasks,
			ArrayList<Task> completedTasks, ArrayList<Task> overdueTasks, ArrayList<Task> results, TreeMap<String, Category> categories) {
		super(cu, floatingTasks, ongoingTasks, completedTasks, overdueTasks, results, categories);
	}

	@Override
	public String execute() {
		ArrayList<Integer> indexes= cu.getTaskToFlagAndMark();
		FLAGANDCOMPLETE_TYPE type = cu.getFlagAndCompleteType();
		switch (type) {
		case SINGLE:
		case RANGE:
		case MULTIPLE:
			return complete(indexes);
		case ALL:
			return completeAll();
		default:
			return MESSAGE_INVALID_COMPLETE;
		}
	}

	private String completeAll() {
		ArrayList<Task> tasks = retrieve(this.UIStatus);
		ArrayList<Integer> indexes = new ArrayList<Integer>();
		
		for (int i=0; i<=tasks.size(); i++) {
			indexes.add(i);
		}
		return complete(indexes);
	}

	private String complete(ArrayList<Integer> indexes) {
		ArrayList<Task> tasks = retrieve(this.UIStatus);
		ArrayList<Integer> unsuccessfulComplete = new ArrayList<Integer>();
		ArrayList<Integer> successfulComplete = new ArrayList<Integer>();
		
		int index;
		for (int i=indexes.size()-1; i>=0; i--) {
			index = indexes.get(i)-INDEX_ADJUSTMENT;
			try {
				Task task = tasks.get(index);
				if (task.getStatus()==TASK_STATUS.COMPLETED) {
					unsuccessfulComplete.add(index + INDEX_ADJUSTMENT);
				}
				else {
					tasks.remove(task);
					if (this.UIStatus==UI_TAB.ALL) {
						this.deleteTaskFromOtherTab(task);
					}
					this.completedTasks.add(task);
					task.setComplete();
					successfulComplete.add(index + INDEX_ADJUSTMENT);
				}
				this.lastModifiedIndex = index;
			} catch (IndexOutOfBoundsException e) {
				unsuccessfulComplete.add(index + INDEX_ADJUSTMENT);
			}
		}
		this.UIStatus = UI_TAB.COMPLETED;
		Collections.sort(successfulComplete);
		Collections.sort(unsuccessfulComplete);
		
		if (unsuccessfulComplete.size()==0) {
			return String.format(MESSAGE_SUCCESSFUL_COMPLETE, successfulComplete);
		}
		if (successfulComplete.size()==0) {
			return String.format(MESSAGE_UNSUCCESSFUL_COMPLETE, unsuccessfulComplete);
		}
		return String.format(MESSAGE_SUCCESSFUL_COMPLETE, successfulComplete) + "\n " + 
				String.format(MESSAGE_UNSUCCESSFUL_COMPLETE, unsuccessfulComplete);
	}
}
```
###### /src/Command/Delete.java
``` java

import java.util.*;

import GUI.UI_TAB;
import Parser.*;
import Task.*;

public class Delete extends Command {
	private static final String MESSAGE_INVALID_DELETE = "Please enter a valid delete command.";
	private static final String MESSAGE_SUCCESSFUL_DELETE = "Task(s) at \"%1$s\" is/are successfully deleted. ";
	private static final String MESSAGE_SUCCESSFUL_DELETE_TAG = "Tag(s) \"%1$s\" are successfully deleted. ";
	private static final String MESSAGE_UNSUCCESSFUL_DELETE_TAG = "Tag(s) \"%1$s\" are not successfully deleted. ";
	private static final String MESSAGE_DELETE_ALL = "All tasks and tags are deleted.";
	
	public Delete(CommandUtils cu, ArrayList<Task> floatingTasks, ArrayList<Task> ongoingTasks,
			ArrayList<Task> completedTasks, ArrayList<Task> overdueTasks, ArrayList<Task> results, TreeMap<String, Category> categories) {
		super(cu, floatingTasks, ongoingTasks, completedTasks, overdueTasks, results, categories);
	}

	public String execute() {
		DELETE_TYPE type = cu.getDeleteType();
		ArrayList<String> tags = cu.getTagToDelete();
		ArrayList<Integer> indexes = cu.getIndexToDelete();

		// SINGLE_INDEX, SINGLE_TAG, MULTIPLE_INDEXES, MULTIPLE_TAGS, RANGE_INDEXES, ALL_INDEXES, ALL_TAGS;
		switch (type) {
		case SINGLE_INDEX:
		case RANGE_INDEXES:
		case MULTIPLE_INDEXES:
			return deleteTask(indexes);
		case ALL_INDEXES:
			return deleteAllTasks();
		case SINGLE_TAG:
		case MULTIPLE_TAGS:
			return deleteCategories(tags);
		case ALL_TAGS:
			return deleteAllTags();
		case START_DATE:
			return convertToDeadlined(indexes);
		case END_DATE:
			return convertToFloating(indexes);
		default:
			return MESSAGE_INVALID_DELETE;
		}
	}
	
	private String deleteTask(ArrayList<Integer> indexes) {
		ArrayList<Task> tasks = retrieve(this.UIStatus);
		System.out.println("====DELETE====" + tasks);
		if (tasks==null || tasks.size()==0) {
			return MESSAGE_EMPTY_LIST;
		}
		
		try {
			for (int i=indexes.size()-1; i>=0; i--) {
				int index = indexes.get(i) - INDEX_ADJUSTMENT;
				Task task = tasks.remove(index);
				if (this.UIStatus==UI_TAB.SEARCH || this.UIStatus==UI_TAB.ALL) {
					deleteTaskFromOtherTab(task);
				}
				this.deleteTaskInCategory(task);
				System.out.println("=====DELTE===== categories: " + this.categories);
			}
		} catch (IndexOutOfBoundsException e) {
			return MESSAGE_INDEXOUTOFBOUND;
		} catch (NullPointerException e) {
			return MESSAGE_EMPTY_LIST;
		}
		return String.format(MESSAGE_SUCCESSFUL_DELETE, indexes);
	}
	
	private String deleteAllTasks() {
		String message;
		if (this.UIStatus!=UI_TAB.ALL) {
			ArrayList<Task> tasks = retrieve(this.UIStatus);
			ArrayList<Integer> indexes = new ArrayList<Integer>();
			for (int i=1; i<=tasks.size(); i++) {
				indexes.add(i);
			}
			message = deleteTask(indexes);
		}
		else {
			this.floatingTasks.clear();
			this.ongoingTasks.clear();
			this.completedTasks.clear();
			this.overdueTasks.clear();
			this.results.clear();
			this.categories.clear();
			message = MESSAGE_DELETE_ALL;
		}
		this.UIStatus = UI_TAB.ALL;
		return message;
	}
	
	private String deleteAllTags() {
		for (Category category: new ArrayList<Category>(this.categories.values())) {
			boolean flag = this.deleteCategory(category.getName());
		}
		return  String.format(MESSAGE_SUCCESSFUL_DELETE_TAG, "ALL");
	}
	
	private String deleteCategories(ArrayList<String> categoriesStr) {
		ArrayList<String> unsuccessfulDeletions = new ArrayList<String>();
		ArrayList<String> successfulDeletions = new ArrayList<String>();
		
		for (String categoryStr: categoriesStr) {
			boolean flag = this.deleteCategory(categoryStr);
			if (flag) successfulDeletions.add(categoryStr);
			else unsuccessfulDeletions.add(categoryStr);
		}
		
		if (unsuccessfulDeletions.size()==0) {
			return String.format(MESSAGE_SUCCESSFUL_DELETE_TAG, successfulDeletions);
		}
		if (successfulDeletions.size()==0) {
			return String.format(MESSAGE_UNSUCCESSFUL_DELETE_TAG, unsuccessfulDeletions);
		}
		return String.format(MESSAGE_SUCCESSFUL_DELETE_TAG, successfulDeletions) + 
				String.format(MESSAGE_UNSUCCESSFUL_DELETE_TAG, unsuccessfulDeletions);
	}
	
	private String convertToDeadlined(ArrayList<Integer> indexes) {
		ArrayList<Task> tasks = retrieve(this.UIStatus); 
		for (Integer index: indexes) {
			Task task = tasks.get(index- INDEX_ADJUSTMENT);
			task.setStart(null);
		}
		this.lastModifiedIndex = indexes.get(indexes.size()-1) - INDEX_ADJUSTMENT;
		return "Start Time of tasks at " + indexes + " has been removed.";
	}
	
	private String convertToFloating(ArrayList<Integer> indexes) {
		ArrayList<Task> tasks = retrieve(this.UIStatus); 
		for (Integer index: indexes) {
			Task task = tasks.get(index - INDEX_ADJUSTMENT);
			task.setEnd(null);
			this.floatingTasks.add(task);
			tasks.remove(index - INDEX_ADJUSTMENT);
			if (this.UIStatus == UI_TAB.SEARCH || this.UIStatus == UI_TAB.ALL) {
				this.deleteTaskFromOtherTab(task);
			}
		}
		this.UIStatus = UI_TAB.FLOATING;
		this.lastModifiedIndex = this.floatingTasks.size()-1;
		return "Deadline of tasks at " + indexes + " has been removed.";
	}
}
```
###### /src/Command/Edit.java
``` java

import java.util.*;

import GUI.UI_TAB;
import Task.*;
import Parser.*;

public class Edit extends Command {
	private static final String MESSAGE_INVALID_EDIT = 
			"Please enter a valid edit.";
	private static final String MESSAGE_SUCCESSFUL_EDIT_NAME = 
			"Task name has been successfully edited to \"%1$s\".";
	private static final String MESSAGE_SUCCESSFUL_EDIT_START = 
			"Task start time has been successfully edited to \"%1$s\".";
	private static final String MESSAGE_SUCCESSFUL_EDIT_END = 
			"Task end time has been successfully edited to \"%1$s\".";
	private static final String MESSAGE_SUCCESSFUL_EDIT_EVENT = 
			"Task event time has been successfully edited to start from \"%1$s\" to \"%2$s\".";
	private static final String MESSAGE_SUCCESSFUL_EDIT_TAG = 
			"Tag name \"%1$s\" has been successfully edit to \"%2$s\".";

	public Edit(CommandUtils cu, ArrayList<Task> floatingTasks, ArrayList<Task> ongoingTasks,
			ArrayList<Task> completedTasks, ArrayList<Task> overdueTasks, ArrayList<Task> results, TreeMap<String, Category> categories) {
		super(cu, floatingTasks, ongoingTasks, completedTasks, overdueTasks, results, categories);
	}

	@Override
	public String execute() {
		EDIT_TYPE edit_type = cu.getEditType();
		int index = cu.getTaskID();
		ArrayList<Task> tasks = this.retrieve(this.UIStatus);
		System.out.println("=====EDIT===== edit_type: " + edit_type);
		try {
			switch (edit_type) {
			case TASK_NAME:
				this.lastModifiedIndex = index - INDEX_ADJUSTMENT;
				Task task = tasks.get(index-INDEX_ADJUSTMENT);
				return editName(task);
			case START_TIME:
				this.lastModifiedIndex = index - INDEX_ADJUSTMENT;
				task = tasks.get(index-INDEX_ADJUSTMENT);
				return editStartTime(task);
			case DEADLINED:
			case END_TIME:
				this.lastModifiedIndex = index - INDEX_ADJUSTMENT;
				task = tasks.get(index-INDEX_ADJUSTMENT);
				return editEndTime(task);
			case EVENT_TIME:
				this.lastModifiedIndex = index - INDEX_ADJUSTMENT;
				task = tasks.get(index-INDEX_ADJUSTMENT);
				return editStartAndEndTime(task);
			case TAG:
				return editTag();
			default:
				return MESSAGE_INVALID_EDIT;
			}
		} catch (IndexOutOfBoundsException e) {
			e.printStackTrace();
			return MESSAGE_INDEXOUTOFBOUND;
		} catch (NullPointerException e) {
			e.printStackTrace();
			return MESSAGE_EMPTY_LIST;
		}
	}
	
	private String editTag() {
		String oldTag = cu.getOldTag();
		String newTag = cu.getTag().get(0);
		
		if (this.editCategory(oldTag, newTag)) {
			return String.format(MESSAGE_SUCCESSFUL_EDIT_TAG, oldTag, newTag);
		}
		else {
			return String.format(MESSAGE_UNSUCCESSFUL_SEARCH_TAG, oldTag);
		}
	}

	private String editName(Task task) {
		String newName = cu.getName();
		task.setName(newName);
		
		return String.format(MESSAGE_SUCCESSFUL_EDIT_NAME, task);
	}
	
	private String editStartTime(Task task) {
		TASK_TYPE oldType = task.getType();
		Date newStartTime = cu.getStartTime();
		
		if (newStartTime.after(task.getEnd())) {
			return MESSAGE_INVALID_START_TIME;
		}
		
		task.setStart(newStartTime);
		if (oldType==TASK_TYPE.FLOATING) {
			convertFromFloating(task);
		}
		return String.format(MESSAGE_SUCCESSFUL_EDIT_START, task.getStartString());
	}
	
	private String editEndTime(Task task) {
		TASK_TYPE oldType = task.getType();
		Date newEndTime = cu.getEndTime();
		
		if (task.getType()==TASK_TYPE.EVENT && newEndTime.before(task.getStart())) {
			return MESSAGE_INVALID_START_TIME;
		}
		
		task.setEnd(newEndTime);
		if (oldType==TASK_TYPE.FLOATING) {
			convertFromFloating(task);
		}
		
		return String.format(MESSAGE_SUCCESSFUL_EDIT_END, task.getEndString());
	}
	
	private String editStartAndEndTime(Task task) {
		TASK_TYPE type = task.getType();
		Date newStartTime = cu.getStartTime();
		Date newEndTime = cu.getEndTime();
		
		if (newStartTime.after(newEndTime)) {
			return MESSAGE_INVALID_EVENT_TIME;
		}
		
		task.setStart(newStartTime);
		task.setEnd(newEndTime);
		if (type==TASK_TYPE.FLOATING) {
			convertFromFloating(task);
		}
		
		return String.format(MESSAGE_SUCCESSFUL_EDIT_EVENT, task.getStartString(), task.getEndString());
	}
	
	private void convertFromFloating(Task task) {
		this.floatingTasks.remove(task);
		if (task.getStatus()==TASK_STATUS.OVERDUE) {
			this.overdueTasks.add(task);
			this.UIStatus = UI_TAB.OVERDUE;
		}
		else if (task.getStatus()==TASK_STATUS.ONGOING) {
			this.ongoingTasks.add(task);
			this.UIStatus = UI_TAB.ONGOING;
		}
	}
}
```
###### /src/Command/Flag.java
``` java

import java.util.ArrayList;
import java.util.TreeMap;

import org.ocpsoft.prettytime.shade.edu.emory.mathcs.backport.java.util.Collections;

import Parser.*;
import Task.Category;
import Task.Task;

public class Flag extends Command {
	private static final String MESSAGE_INVALID_FLAG = "Please enter a valid flag command.";
	private static final String MESSAGE_SUCCESSFUL_FLAG = 
			"Task(s) at \"%1$s\" is/are successfully flagged. ";
	private static final String MESSAGE_SUCCESSFUL_UNFLAG =
			"Task(s) at \"%1$s\" is/are successfully unflagged. ";
	private static final String MESSAGE_UNSUCCESSFUL_FLAG = 
			"Task(s) at \"%1$s\" failed to flag due to its/their invalid index or already flagged/unflagged status. ";
	private static final String MESSAGE_UNSUCCESSFUL_UNFLAG = 
			"Task(s) at \"%1$s\" failed to unflag due to its/their invalid index or already flagged/unflagged status. ";
	private boolean toFlag;

	public Flag(CommandUtils cu, ArrayList<Task> floatingTasks, ArrayList<Task> ongoingTasks,
			ArrayList<Task> completedTasks, ArrayList<Task> overdueTasks, ArrayList<Task> results, TreeMap<String, Category> categories, boolean toFlag) {
		super(cu, floatingTasks, ongoingTasks, completedTasks, overdueTasks, results, categories);
		this.toFlag = toFlag;
	}

	@Override
	public String execute() {
		ArrayList<Integer> indexes = cu.getTaskToFlagAndMark();
		FLAGANDCOMPLETE_TYPE type = cu.getFlagAndCompleteType();
		switch (type) {
		case SINGLE:
		case RANGE:
		case MULTIPLE:
			return flag(indexes);
		case ALL:
			return flagAll();
		default:
			return MESSAGE_INVALID_FLAG;
		}
	}

	private String flagAll() {
		ArrayList<Task> tasks = retrieve(this.UIStatus);
		ArrayList<Integer> indexes = new ArrayList<Integer>();

		for (int i=1; i<=tasks.size(); i++) {
			indexes.add(i);
		}
		return flag(indexes);
	}

	private String flag(ArrayList<Integer> indexes) {
		ArrayList<Task> tasks = retrieve(this.UIStatus);
		ArrayList<Integer> successfulUnflag = new ArrayList<Integer>();
		ArrayList<Integer> unsuccessfulUnflag = new ArrayList<Integer>();
		ArrayList<Integer> successfulFlag = new ArrayList<Integer>();
		ArrayList<Integer> unsuccessfulFlag = new ArrayList<Integer>();

		int index = 0;
		for (int i=indexes.size()-1; i>=0; i--) {
			index = indexes.get(i)-1;
			try {
				Task task = tasks.get(index);
				if (toFlag) {
					// user wants to flags
					if (task.getFlag()) {
						unsuccessfulFlag.add(index + INDEX_ADJUSTMENT);
					}
					else {
						successfulFlag.add(index + INDEX_ADJUSTMENT);
					}
				}
				else {
					if (!task.getFlag()) {
						unsuccessfulUnflag.add(index + INDEX_ADJUSTMENT);
					}
					else {
						successfulUnflag.add(index + INDEX_ADJUSTMENT);
					}
				}
				task.setFlag(toFlag);
				this.lastModifiedIndex = index;
			} catch (IndexOutOfBoundsException e) {
				unsuccessfulFlag.add(index + INDEX_ADJUSTMENT);
			}
		}

		Collections.sort(successfulFlag);
		Collections.sort(unsuccessfulFlag);
		Collections.sort(successfulUnflag);
		Collections.sort(unsuccessfulUnflag);

		if (this.toFlag) {
			if (unsuccessfulFlag.size()==0) {
				return String.format(MESSAGE_SUCCESSFUL_FLAG, successfulFlag);
			}
			if (successfulFlag.size()==0) {
				return String.format(MESSAGE_UNSUCCESSFUL_FLAG, unsuccessfulFlag);
			}
			return String.format(MESSAGE_SUCCESSFUL_FLAG, successfulFlag) + "\n " + 
			String.format(MESSAGE_UNSUCCESSFUL_FLAG, unsuccessfulFlag);
		}
		else {
			if (unsuccessfulUnflag.size()==0) {
				return String.format(MESSAGE_SUCCESSFUL_UNFLAG, successfulUnflag);
			}
			if (successfulUnflag.size()==0) {
				return String.format(MESSAGE_UNSUCCESSFUL_UNFLAG, unsuccessfulUnflag);
			}
			return String.format(MESSAGE_SUCCESSFUL_UNFLAG, successfulUnflag) + "\n " + 
			String.format(MESSAGE_UNSUCCESSFUL_UNFLAG, unsuccessfulUnflag);
		}
	}
}
```
###### /src/Command/Search.java
``` java

import java.util.*;

import GUI.UI_TAB;
import Parser.*;
import Task.*;

public class Search extends Command {
	private static final String MESSAGE_INVALID_SEARCH = "Please enter a valid search command.";
	private static final String MESSAGE_SUCCESSFUL_SEARCH_KEYWORD = "Search keyword \"%1$s\" is successful.";
	private static final String MESSAGE_SUCCESSFUL_SEARCH_TAG = "Search tag \"%1$s\" is successful.";
	private static final String MESSAGE_UNSUCCESSFUL_SEARCH_KEYWORD = "There is no task named \"%1$s\".";
	
	public Search(CommandUtils cu, ArrayList<Task> floatingTasks, ArrayList<Task> ongoingTasks,
			ArrayList<Task> completedTasks, ArrayList<Task> overdueTasks, ArrayList<Task> results, TreeMap<String, Category> categories) {
		super(cu, floatingTasks, ongoingTasks, completedTasks, overdueTasks, results, categories);
	}
	@Override
	public String execute() {
		SEARCH_TYPE type = cu.getSearchType();
		switch (type) {
		case BY_TASK:
			String keyword = cu.getSearchByTask();
			return searchByKeyword(keyword);
		case BY_TAG:
			String searchTag = cu.getSearchByTag();
			return searchByTag(searchTag);
		case INVALID:
		default:
			return MESSAGE_INVALID_SEARCH;
		}
	}
	
	/**********************************INTERNAL METHODS***************************************/
	private String searchByTag(String searchTag) {
		Category category = this.findCategory(searchTag);
		if (category==null) {
			return String.format(MESSAGE_UNSUCCESSFUL_SEARCH_TAG, searchTag);
		}
		this.results.addAll(category.getTasks());
		this.UIStatus = UI_TAB.SEARCH;
		return String.format(MESSAGE_SUCCESSFUL_SEARCH_TAG, searchTag);
	}

	private String searchByKeyword(String keyword) {
		if (keyword.length()<2) {
			return MESSAGE_INVALID_SEARCH;
		}
		
		ArrayList<Task> floatingResults = searchTasksByKeyword(floatingTasks, keyword);
		ArrayList<Task> ongoingResults = searchTasksByKeyword(ongoingTasks, keyword);
		ArrayList<Task> completedResults = searchTasksByKeyword(completedTasks, keyword);
		ArrayList<Task> overdueResults = searchTasksByKeyword(overdueTasks, keyword);
		this.results.addAll(floatingResults);
		this.results.addAll(ongoingResults);
		this.results.addAll(completedResults);
		this.results.addAll(overdueResults);
		this.UIStatus = UI_TAB.SEARCH;
		
		if (this.results.size()==0) {
			return String.format(MESSAGE_UNSUCCESSFUL_SEARCH_KEYWORD, keyword);
		}
		return String.format(MESSAGE_SUCCESSFUL_SEARCH_KEYWORD, keyword);
	}

	private ArrayList<Task> searchTasksByKeyword(ArrayList<Task> tasks, String searchStr) {
		searchStr = searchStr.toLowerCase();
		String[] fragments = searchStr.split(" ");
		
		ArrayList<Task> results = new ArrayList<Task>();
		for (Task task: tasks) {
			String name = task.getName().toLowerCase();
			
			boolean search = true;
			for (String fragment: fragments) {
				if (!name.contains(fragment)) search = false;
			}
			if (search==true) results.add(task);
		}
		return results;
	}
}
```
###### /src/Command/Sort.java
``` java

import java.util.*;

import Parser.*;
import Task.*;

public class Sort extends Command {
	private static final String INVALID_SORT = "Please enter a valid sort command.";
	private static final DescendingAlphabeticalComparator decendingAlphabeticalComparator = new DescendingAlphabeticalComparator();
	private static final AscendingAlphaticalComparator ascendingAlphabeticalComparator = new AscendingAlphaticalComparator();
	private static final DateComparator dateComparator = new DateComparator();

	public Sort(CommandUtils cu, ArrayList<Task> floatingTasks, ArrayList<Task> ongoingTasks,
			ArrayList<Task> completedTasks, ArrayList<Task> overdueTasks, ArrayList<Task> results, TreeMap<String, Category> categories) {
		super(cu, floatingTasks, ongoingTasks, completedTasks, overdueTasks, results, categories);
	}

	@Override
	public String execute() {
		SORT_TYPE type = cu.getSortType();
		switch (type) {
		case BY_ASCENDING:
		case BY_DESCENDING:
			return sortByAlphabet(type);
		case BY_DATE:
			return sortByDate();
		default: 
			return INVALID_SORT;
		}
	}

	public String sortByAlphabet(SORT_TYPE type) {
		ArrayList<Task> tasks = retrieve(this.UIStatus);
		if (tasks.size()==0) {
			return MESSAGE_EMPTY_LIST;
		}
		if (type==SORT_TYPE.BY_DESCENDING) {
			Collections.sort(tasks, decendingAlphabeticalComparator);
		}
		else {
			Collections.sort(tasks, ascendingAlphabeticalComparator);
		}
		return "Sorted by Alphabets.";
	}
	
	public String sortByDate() {
		ArrayList<Task> tasks = retrieve(this.UIStatus);
		if (tasks.size()==0) {
			return MESSAGE_EMPTY_LIST;
		}
		Collections.sort(tasks, dateComparator);
		return "Sorted by Dates.";
	}


	private static class AscendingAlphaticalComparator implements Comparator<Task> {
		@Override
		public int compare(Task a, Task b) {
			String nameA = a.getName();
			String nameB = b.getName();
			int comp = nameA.compareToIgnoreCase(nameB);
			return comp;
		}
	}
	
	private static class DescendingAlphabeticalComparator implements Comparator<Task> {
		@Override
		public int compare(Task a, Task b) {
			String nameA = a.getName();
			String nameB = b.getName();
			int comp = nameB.compareToIgnoreCase(nameA);
			return comp;
		}
	}
	
	private static class DateComparator implements Comparator<Task> {
		@Override
		public int compare(Task a, Task b) {
			Date aDate = a.getEnd();
			Date bDate = b.getEnd();
			if (aDate==null && bDate==null) return -1;
			if (aDate==null) return 1;
			if (bDate==null) return -1;
			if (aDate.after(bDate)) {
				return 1;
			}
			else if (aDate.before(bDate)) {
				return -1;
			}
			else return 0;
		}
	}
}
```
###### /src/Command/Tag.java
``` java

import java.util.*;

import Parser.*;
import Task.Category;
import Task.Task;

public class Tag extends Command {
	private static final String MESSAGE_SUCCESSFUL_TAG = 
			"Task(s) \"%1$s\" is/are successfully tagged by \"%2$s\". ";
	private static final String MESSAGE_UNSUCCESSFUL_TAG = 
			"Task(s) \"%1$s\" failed to be tagged by \"%2$s\", because it has been already tagged before. ";
	
	public Tag(CommandUtils cu, ArrayList<Task> floatingTasks, ArrayList<Task> ongoingTasks,
			ArrayList<Task> completedTasks, ArrayList<Task> overdueTasks, ArrayList<Task> results, TreeMap<String, Category> categories) {
		super(cu, floatingTasks, ongoingTasks, completedTasks, overdueTasks, results, categories);
	}

	@Override
	public String execute() {
		int index = cu.getTaskID();
		ArrayList<String> tags = cu.getTag();
		ArrayList<Task> tasks = retrieve(this.UIStatus);
		
		Task task;
		try {
			task = tasks.get(index-INDEX_ADJUSTMENT);
			this.lastModifiedIndex = index - INDEX_ADJUSTMENT;
		} catch (IndexOutOfBoundsException e) {
			return MESSAGE_INDEXOUTOFBOUND;
		} catch (NullPointerException e) {
			return MESSAGE_EMPTY_LIST;
		}

		return tag(tags, task);
	}

	private String tag(ArrayList<String> tags, Task task) {
		ArrayList<String> unsuccessfulTags = new ArrayList<String>();
		ArrayList<String> successfulTags = new ArrayList<String>();
		
		for (String tag: tags) {
			if (tag == null || tag.equals("")) continue;
			if (this.tagTask(tag, task)) {
				successfulTags.add(tag);
			}
			else {
				// already tagged
				unsuccessfulTags.add(tag);
			}
		}
		if (unsuccessfulTags.size()==0) {
			return String.format(MESSAGE_SUCCESSFUL_TAG, task, successfulTags);
		}
		if (successfulTags.size()==0) {
			return String.format(MESSAGE_UNSUCCESSFUL_TAG, task, unsuccessfulTags);
		}
		return String.format(MESSAGE_SUCCESSFUL_TAG, task, successfulTags) + 
				String.format(MESSAGE_UNSUCCESSFUL_TAG, task, unsuccessfulTags);
		
	}
}
```
###### /src/GUI/UI_TAB.java
``` java
public enum UI_TAB {
	MAIN, ALL, FLOATING, ONGOING, COMPLETED, OVERDUE, SEARCH, HELP;
}
```
###### /src/Logic/History.java
``` java

import java.util.*;
import Task.*;

public class History {
	private static Stack<ArrayList<ArrayList<Task>>> undo_data;
	private static Stack<ArrayList<ArrayList<Task>>> redo_data;
	private static Stack<TreeMap<String, Category>> undo_categories;
	private static Stack<TreeMap<String, Category>> redo_categories;
	
	public History() {
		undo_data = new Stack<ArrayList<ArrayList<Task>>>();
		redo_data = new Stack<ArrayList<ArrayList<Task>>>();
		undo_categories = new Stack<TreeMap<String, Category>>();
		redo_categories = new Stack<TreeMap<String, Category>>();
	}

	public String save(ArrayList<ArrayList<Task>> data, TreeMap<String, Category> categories) {
		undo_data.push(data);
		undo_categories.push(categories);
		redo_data = new Stack<ArrayList<ArrayList<Task>>>();
		redo_categories = new Stack<TreeMap<String, Category>>();
		return "[INTERNAL MESSAGE/HISTORY]: data saved.";
	}
	
	public ArrayList<ArrayList<Task>> undoData(ArrayList<ArrayList<Task>> data) {
		redo_data.push(data);
		return undo_data.pop();
	}
	
	public TreeMap<String, Category> undoCategories(TreeMap<String, Category> categories) {
		redo_categories.push(categories);
		return undo_categories.pop();
	}
	
	public ArrayList<ArrayList<Task>> redoData() {
		return redo_data.pop();
	}
	
	public TreeMap<String, Category> redoCategories() {
		return redo_categories.pop();
	}
}
```
###### /src/Logic/Logic.java
``` java

public class Logic {
	private static final String MESSAGE_SUCCESSFUL_UNDO = "Undo successful.";
	private static final String MESSAGE_SUCCESSFUL_REDO = "Redo successful.";
	private static final String MESSAGE_SUCCESSFUL_SAVE = "Save successful.";
	private static final String MESSAGE_UNSUCCESSFUL_UNDO = "Undo not successful. There is nothing to undo";
	private static final String MESSAGE_UNSUCCESSFUL_REDO = "Redo not successful. There is nothing to redo";
	private static final String MESSAGE_SWITCH_VIEW = "Successfully switch to %1$s.";
	private static final String MESSAGE_INVALID_COMMAND = "Please enter a valid command.";
	private static Logic theOne; //singleton
	private Storage storage;

	/*************************************MEMORY*************************************************/
	private ArrayList<Task> ongoingTasks;
	private ArrayList<Task> completedTasks;
	private ArrayList<Task> overdueTasks;
	private ArrayList<Task> floatingTasks;
	private ArrayList<Task> results;
	private TreeMap<String, Category> categories;
	private History history;
	private UI_TAB status;
	private String previous;
	private int lastModifiedIndex;

	/*************************************PUBLIC METHODS******************************************/
	/**
	 * This method constructs an instance of Logic.
	 * It implements Singleton Pattern so that only one instance of Logic is allowed to be constructed at all time.
	 * It initializes appropriate attributes such as Storage, History and ArrayLists.
	 * It must be called before using any other methods of Logic.
	 * 
	 * @return {@code Logic theOne}
	 */
	public static Logic getInstance() {
		if (theOne==null) {
			theOne = new Logic();
		}
		return theOne;
	}
	
	/**
	 * This method constructs an instance of Parser.
	 * It processes the user input and update its attributes correspondingly.
	 * 
	 * @param  {@code String input}
	 * @return {@code String feedback}
	 */
	public String run(String input) {
		this.previous = input;
		CommandUtils cu = new CommandUtils();
		Parser parser = new Parser();
		try {
			cu = parser.executeCommand(cu, input);
		} catch (Exception e) {
			return MESSAGE_INVALID_COMMAND;
		}
		String message = processCommand(cu);
		return message;
	}
	
	/**
	 * This method saves all its memory, or its attributes to Storage.
	 * 
	 * @return {@code String feedback}
	 */
	public String save() {
		storage.save(TASK_STATUS.ONGOING, ongoingTasks);
		storage.save(TASK_STATUS.COMPLETED, completedTasks);
		storage.save(TASK_STATUS.FLOATING, floatingTasks);
		storage.save(TASK_STATUS.OVERDUE, overdueTasks);
		storage.saveCategories(this.categories);
		return MESSAGE_SUCCESSFUL_SAVE;
	}
	
	/**
	 * This method converts categories of type ArrayList of String,
	 * to type of ArrayList of Category,
	 * @param categoriesString
	 * @return {@code ArrayList<Category> categories}
	 */
	public ArrayList<Category> mapCategories(ArrayList<String> categoriesString) {
		ArrayList<Category> categories = new ArrayList<Category>();
		for (String categoryString: categoriesString) {
			Category category = this.categories.get(categoryString.toLowerCase());
			if (category!=null) {
				categories.add(category);
			}
		}
		return categories;
	}
	
	/**
	 * This method updates all its memory with the latest System time.
	 *
	 */
	public void update() {
		this.updateList(this.floatingTasks);
		this.updateList(this.ongoingTasks);
		this.updateList(this.completedTasks);
		this.updateList(this.overdueTasks);
	}
	/***********************************ACCESSORS***********************************************/
	public ArrayList<Task> getOngoingTasks() {
		return this.ongoingTasks;
	}

	public ArrayList<Task> getFloatingTasks() {
		return this.floatingTasks;
	}

	public ArrayList<Task> getCompletedTasks() {
		return this.completedTasks;
	}

	public ArrayList<Task> getOverdueTasks() {
		return this.overdueTasks;
	}

	public ArrayList<Category> getCategories() {
		ArrayList<Category> categories = new ArrayList<Category>(this.categories.values());
		return categories;
	}

	public ArrayList<Task> getAll() {
		ArrayList<Task> temp = new ArrayList<Task>();
		temp.addAll(this.overdueTasks);
		temp.addAll(this.ongoingTasks);
		temp.addAll(this.floatingTasks);
		temp.addAll(this.completedTasks);
		return temp;
	}

	public UI_TAB getStatus() {
		return this.status;
	}

	public ArrayList<Task> getSearchResults() {
		return this.results;
	}

	public String getPreviousCommand() {
		if (this.previous==null) {
			return "";
		}
		return this.previous;
	}
	
	public int getLastModifiedIndex() {
		return this.lastModifiedIndex;
	}

	/***********************************PRIVATE METHODS***********************************************/
	private String processCommand(CommandUtils cu) {
		String message = "";
		COMMAND_TYPE command = cu.getCommandType();
		System.out.println("=====COMMAND===== command: " + command);
		System.out.println(command);

		switch (command) {
		case ADD:
			Add add = new Add(cu, this.floatingTasks, this.ongoingTasks, 
					this.completedTasks, this.overdueTasks, this.results, this.categories);
			message = execute(add);
			break;
		case DELETE:
			Delete delete = new Delete(cu, this.floatingTasks, this.ongoingTasks, 
					this.completedTasks, this.overdueTasks, this.results, this.categories);
			message = execute(delete);
			break;
		case EDIT:
			Edit edit = new Edit(cu, this.floatingTasks, this.ongoingTasks, 
					this.completedTasks, this.overdueTasks, this.results, this.categories);
			message = execute(edit);
			break;
		case COMPLETE:
			Complete complete = new Complete(cu, this.floatingTasks, this.ongoingTasks, 
					this.completedTasks, this.overdueTasks, this.results, this.categories);
			message = execute(complete);
			break;
		case TAG:
			Tag tag = new Tag(cu, this.floatingTasks, this.ongoingTasks, 
					this.completedTasks, this.overdueTasks, this.results, this.categories);
			message = execute(tag);
			categories = tag.getCategories();
			break;
		case FLAG:
			Flag flag = new Flag(cu, this.floatingTasks, this.ongoingTasks, 
					this.completedTasks, this.overdueTasks, this.results, this.categories, true);
			message = execute(flag);
			break;
		case UNFLAG:
			flag = new Flag(cu, this.floatingTasks, this.ongoingTasks, 
					this.completedTasks, this.overdueTasks, this.results, this.categories, false);
			message = execute(flag);
			break;
		case UNDO:
			try {
				this.update(this.history.undoData(this.compress()), this.history.undoCategories(categories));
				message = MESSAGE_SUCCESSFUL_UNDO;
			} catch (EmptyStackException e) {
				message = MESSAGE_UNSUCCESSFUL_UNDO;
			}
			break;
		case REDO:
			try {
				this.update(this.history.redoData(), this.history.redoCategories());
				message = MESSAGE_SUCCESSFUL_REDO;
			} catch (EmptyStackException e) {
				message = MESSAGE_UNSUCCESSFUL_REDO;
			}
			break;
		case SEARCH:
			this.results.clear();
			Search search = new Search(cu, this.floatingTasks, this.ongoingTasks, 
					this.completedTasks, this.overdueTasks, this.results, this.categories);
			message = execute(search);
			break;
		case SORT:
			Sort sort = new Sort(cu, this.floatingTasks, this.ongoingTasks, 
					this.completedTasks, this.overdueTasks, this.results, this.categories);
			message = execute(sort);
			break;
		case CHANGE_DIRECTORY:
			message = this.redirect();
			break;
		case INVALID:
		default:
			message = MESSAGE_INVALID_COMMAND;
		}
		return message;
	}

	private String execute(Command command) {
		history.save(compress(), cloneCategories(this.categories));
		String message = command.execute();
		this.status = command.getStatus();
		this.lastModifiedIndex = command.getLastModifiedIndex();
		return message;
	}

	private void updateList(ArrayList<Task> list) {
		for (Task task: list) {
			boolean updated = task.update();
			if (updated) {
				TASK_STATUS newStatus = task.getStatus();
				list.remove(task);
				ArrayList<Task> newList = retrieve(newStatus);
				newList.add(task);
				System.out.println("=====LOGIC===== update: " + updated);
			}
		}
	}
	
	private String redirect() {
		this.storage.redirect();
		return this.save();
	}

	/***************************************DATA MANIPULATION***********************************/
	private String update(ArrayList<ArrayList<Task>> data, TreeMap<String, Category> categories) {
		this.floatingTasks = data.get(0);
		this.ongoingTasks = data.get(1);
		this.completedTasks = data.get(2);
		this.overdueTasks = data.get(3);
		this.results = data.get(4);
		this.categories = categories;
		return "Data updated.";
	}

	private ArrayList<ArrayList<Task>> compress() {
		ArrayList<ArrayList<Task>> data = new ArrayList<ArrayList<Task>> ();
		data.add(cloneList(this.floatingTasks));
		data.add(cloneList(this.ongoingTasks));
		data.add(cloneList(this.completedTasks));
		data.add(cloneList(this.overdueTasks));
		data.add(cloneList(this.results));
		return data;
	}

	private ArrayList<Task> retrieve(TASK_STATUS status) {
		switch (status) {
		case ONGOING:
			return this.ongoingTasks;
		case FLOATING:
			return this.floatingTasks;
		case COMPLETED:
			return this.completedTasks;
		case OVERDUE:
			return this.overdueTasks;
		default:
			return null;
		}
	}

	/**********************************FOR UNDO/REDO**********************************************************/
	private ArrayList<Task> cloneList(ArrayList<Task> original) {
		ArrayList<Task> newList = new ArrayList<Task>();
		for (int i=0; i<original.size(); i++) {
			Task task = new Task(original.get(i));
			newList.add(task);
		}
		return newList;
	}

	private TreeMap<String, Category> cloneCategories(TreeMap<String, Category> original) {
		TreeMap<String, Category> newCategories = new TreeMap<String, Category>();
		ArrayList<Category> categories = new ArrayList<Category>(original.values());
		for (Category category: categories) {
			Category newCategory = new Category(category);
			newCategories.put(category.getName().toLowerCase(), newCategory);
		}
		return newCategories;
	}

	/***********************************INITALISE*****************************************************/
	private Logic() {
		storage = Storage.getInstance();
		results = new ArrayList<Task>();
		history = new History();
		ongoingTasks = storage.read(TASK_STATUS.ONGOING);
		completedTasks = storage.read(TASK_STATUS.COMPLETED);
		overdueTasks = storage.read(TASK_STATUS.OVERDUE);
		floatingTasks = storage.read(TASK_STATUS.FLOATING);
		categories = storage.readCategories();
	}

	/*private TreeMap<String, Category> initialiseCategories(ArrayList<Task> ongoingTasks, ArrayList<Task> completedTasks,
			ArrayList<Task> overdueTasks, ArrayList<Task> floatingTasks) {
		TreeMap<String, Category> categories = new TreeMap<String, Category>();
		categories = loadCategoriesFromList(ongoingTasks, categories);
		categories = loadCategoriesFromList(floatingTasks, categories);
		categories = loadCategoriesFromList(completedTasks, categories);
		categories = loadCategoriesFromList(overdueTasks, categories);
		return categories;
	}

	private TreeMap<String, Category> loadCategoriesFromList(ArrayList<Task> tasks,
			TreeMap<String, Category> categories) {
		for (Task task: tasks) {
			ArrayList<String> taskCategories = task.getCategories();
			for (String category: taskCategories) {
				if (!categories.containsKey(category.toLowerCase())) {
					categories.put(category.toLowerCase(), category);
				}
			}
		}
		return categories;
	}*/
}
```
###### /src/Storage/Storage.java
``` java

import Command.*;
import GUI.*;
import Logic.*;
import Parser.*;
import Task.*;

import java.io.*;
import java.lang.reflect.Type;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;

import com.google.gson.*;
import com.google.gson.reflect.TypeToken;

public class Storage {
	private static final String MESSAGE_INVALID_TASK_STATUS = "Task status \"%1$s\" is invalid.";
	private static final String MESSAGE_SUCCESSFUL_FILE_SAVE = "%1$s is successfully saved.";
	private static final String FILENAME_ONGOING_TASKS = "OngoingTasks.txt";
	private static final String FILENAME_COMPLETED_TASKS = "CompletedTasks.txt";
	private static final String FILENAME_FLOATING_TASKS = "FloatingTasks.txt";
	private static final String FILENAME_OVERDUE_TASKS = "OverdueTasks.txt";
	private static final String FILENAME_CATEGORIES = "Categories.txt";
	private static final String FILENAME_CONFIG = "Config.txt";

	private static Storage theOne;
	private PrintWriter pw;
	private BufferedReader br;
	private File floating;
	private File ongoing;
	private File completed;
	private File overdue;
	private File categories;
	private String folderDirectory;
	
	/**
	 * This method constructs an instance of Storage.
	 * It implements Singleton Pattern so that only one instance of Storage is allowed to be constructed at all time.
	 * It initializes its memory, or its attributes. 
	 * @return {@code Storage theOne}
	 */
	public static Storage getInstance() {
		if (theOne==null) {
			theOne = new Storage();
		}
		return theOne;
	}
	
	/**
	 * This method reads ArrayList<Task> attributes from a specific text file on disk storage.
	 * It inputs a TASK_STATUS enum type and outputs the corresponding tasks list.
	 * @param {@code TASK_STATUS task_status}
	 * @return {@code ArrayList<Task> tasks}
	 */
	public ArrayList<Task> read(TASK_STATUS task_status) {
		switch (task_status) {
		case ONGOING:
			return readFromFile(this.ongoing);
		case COMPLETED:
			return readFromFile(this.completed);
		case FLOATING:
			return readFromFile(this.floating);
		case OVERDUE:
			return readFromFile(this.overdue);
		default:
			return null;
		}
	}
	
	/**
	 * This method saves ArrayList<Task> attributes into a text file residing on disk storage.
	 * 
	 * @param {@code TASK_STATUS task_status}
	 * @param {@code ArrayList<Task> tasks}
	 * @return {@code String feedback}
	 */
	public String save(TASK_STATUS task_status, ArrayList<Task> tasks) {
		switch (task_status) {
		case ONGOING:
			return printToFile(this.ongoing, tasks);
		case COMPLETED:
			return printToFile(this.completed, tasks);
		case FLOATING:
			return printToFile(this.floating, tasks);
		case OVERDUE:
			return printToFile(this.overdue, tasks);
		default:
			return MESSAGE_INVALID_TASK_STATUS;
		}
	}
	
	/**
	 * This method reads TreeMap<String, Category> categories from a specific text file on disk storage.
	 * 
	 * @return {@code TreeMap<String, Category> categories}
	 */

	public TreeMap<String, Category> readCategories() {
		TreeMap<String, Category> categories = new TreeMap<String, Category>();
		try {
			br = new BufferedReader(new FileReader(this.categories));
			GsonBuilder gsonBuilder = new GsonBuilder().setDateFormat("dd/MM/yyyy HH:mm:ss");
			Gson gson = gsonBuilder.create();
			categories = gson.fromJson(br, new TypeToken<TreeMap<String, Category>>() {}.getType());
			br.close();
			if (categories==null) {
				categories = new TreeMap<String, Category>();
			}
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return categories;
	}
	
	/**
	 * This method saves TreeMap<String, Cateogory> categories into a text file on disk storage.
	 * @param categories
	 * @return {@code String feedback}
	 */
	public String saveCategories(TreeMap<String, Category> categories)  {
		this.categories.delete();
		try (Writer writer = new OutputStreamWriter(new FileOutputStream(this.categories), "UTF-8")) {
			GsonBuilder gsonBuilder = new GsonBuilder().setDateFormat("dd/MM/yyyy HH:mm:ss").setPrettyPrinting();
			Gson gson = gsonBuilder.create();
			gson.toJson(categories, writer);
			writer.close();
		}
		catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
		catch (IOException e) {
			e.printStackTrace();
		}
		return String.format(MESSAGE_SUCCESSFUL_FILE_SAVE, this.categories);
	}
	
	/**
	 * This method redirects storage files to a new directory on the disk.
	 */
	public void redirect() {
		this.floating.delete();
		this.ongoing.delete();
		this.completed.delete();
		this.overdue.delete();
		this.categories.delete();
		File oldDirectory = new File(this.folderDirectory);
		oldDirectory.delete();
		this.folderDirectory = saveConfig();
		
		intialise(this.folderDirectory);
	}
	/******************************INTERNAL***********************************************/
	private Storage() {
		this.folderDirectory = this.configDirectory();	
		this.intialise(this.folderDirectory);
	}
	
	private void intialise(String directory) {
		this.overdue = new File(directory + FILENAME_OVERDUE_TASKS);
		this.ongoing = new File(directory  + FILENAME_ONGOING_TASKS);
		this.floating = new File(directory + FILENAME_FLOATING_TASKS); 
		this.completed = new File(directory + FILENAME_COMPLETED_TASKS);
		this.categories = new File(directory + FILENAME_CATEGORIES);

		if (!this.categories.exists()) initialiseFile(this.categories);
		if (!this.ongoing.exists()) initialiseFile(this.ongoing);
		if (!this.completed.exists()) initialiseFile(this.completed);
		if (!this.floating.exists()) initialiseFile(this.floating);
		if (!this.overdue.exists()) initialiseFile(this.overdue);
	}
	
	private String configDirectory() {
		File config = new File(FILENAME_CONFIG);
		String directory = null;
		if (config.exists()) {
			directory = readConfig(config);
		} 
		else {
			directory = saveConfig();
		}
		return directory;
	}

	private String saveConfig() {
		String directory = null;
		try {
			pw = new PrintWriter(new BufferedWriter(new FileWriter(FILENAME_CONFIG, false)));
			File folder = UIConfiguration.openDialogBox();
			directory = folder.getAbsolutePath() + "/";
			pw.println(directory);
			pw.flush();
			pw.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return directory;
	}

	private String readConfig(File config) {
		String directory = null;
		try {
			br = new BufferedReader(new FileReader(config));
			directory = br.readLine();
			br.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return directory;

	}

	private String printToFile(File file, ArrayList<Task> tasks)  {
		file.delete();
		try (Writer writer = new OutputStreamWriter(new FileOutputStream(file), "UTF-8")) {
			GsonBuilder gsonBuilder = new GsonBuilder().setDateFormat("dd/MM/yyyy HH:mm:ss").setPrettyPrinting();
			Gson gson = gsonBuilder.create();
			gson.toJson(tasks, writer);
			writer.close();
		}
		catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
		catch (IOException e) {
			e.printStackTrace();
		}
		return String.format(MESSAGE_SUCCESSFUL_FILE_SAVE, file);
	}

	private ArrayList<Task> readFromFile(File file) {
		ArrayList<Task> tasks = new ArrayList<Task>();
		try {
			br = new BufferedReader(new FileReader(file));
			GsonBuilder gsonBuilder = new GsonBuilder().setDateFormat("dd/MM/yyyy HH:mm:ss");
			Gson gson = gsonBuilder.create();
			tasks = gson.fromJson(br, new TypeToken<ArrayList<Task>>() {}.getType());
			if (tasks==null) {
				tasks = new ArrayList<Task>();
			}
			br.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return tasks;
	}

	private void initialiseFile(File file) {
		try {
			pw = new PrintWriter(new BufferedWriter(new FileWriter(file, true)));
			pw.print("");
			pw.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
```
###### /src/Task/Category.java
``` java

import java.util.*;

public class Category {
	private String name;
	private ArrayList<Task> tasks;
	
	public Category() {
		this("");
	}
	
	public Category(String name) {
		this.name = name;
		this.tasks = new ArrayList<Task>();
	}
	
	public Category(Category category) {
		this.name = category.getName();
		this.tasks = category.getTasks();
	}
	
	/****************************MUTATORS******************************/
	public boolean addTask(Task task) {
		if (!tasks.contains(task)) {
			tasks.add(task);
			boolean flag = task.addCategory(this.name);
			System.out.println("[DUBUG] task flag: " + flag);
			return flag;
		}
		return false;
	}
	
	public boolean deleteTask(Task task) {
		if (tasks.contains(task)) {
			tasks.remove(task);
			return true;
		}
		return false;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	
	/****************************ACCESSORS*****************************/
	public String getName() {
		return this.name;
	}
	
	public ArrayList<Task> getTasks() {
		return this.tasks;
	}
	
	@Override
	public String toString() {
		return "#" + name;
	}
}
```
###### /src/Task/Task.java
``` java

public class Task {
	private static final SimpleDateFormat datetimeFormater = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
	private static final SimpleDateFormat dateFormater = new SimpleDateFormat("dd/MM/yyyy");
	private static final SimpleDateFormat timeFormatter = new SimpleDateFormat("HH:mm:ss");
	private TASK_TYPE type;
	private TASK_STATUS status;
	private String name;
	private Date start;
	private Date end;
	private boolean flag;
	private ArrayList<String> categories;

	// Default Constructor
	public Task() {
		this("");
	}

	// Constructor of Floating Tasks
	public Task(String name) {
		this.type = TASK_TYPE.FLOATING;
		this.status = TASK_STATUS.FLOATING;
		this.name = name; // must have

		this.categories = new ArrayList<String>();
		this.flag = false;
	}

	// Constructor of Deadlined Tasks
	public Task(String name, Date end) {
		this.type = TASK_TYPE.DEADLINED;
		this.name = name;
		/*this.end = formatter.format(end);*/
		this.end = end;
		this.status = checkOverdue(end);

		this.categories = new ArrayList<String>();
		this.flag = false;;
	}

	// Constructor of Event
	public Task(String name, Date start, Date end) {
		this.type = TASK_TYPE.EVENT;
		this.name = name;
		this.end = end;
		this.start = start;
		this.status = checkOverdue(end);

		this.categories = new ArrayList<String>();
		this.flag = false;
	}

	// copy constructor
	public Task(Task original) {
		this.type = original.type;
		this.status = original.status;
		this.name = original.name;
		this.end = original.end;
		this.start = original.start;
		this.flag = original.flag;
		this.categories = original.categories;
	}

	/**************************************ACCESSORS**************************/
	public TASK_TYPE getType() {
		return this.type;
	}

	public TASK_STATUS getStatus() {
		return this.status;
	}

	public boolean getFlag() {
		return this.flag;
	}

	public String getName() {
		return this.name;
	}

	public ArrayList<String> getCategories() {
		return this.categories;
	}

	public Date getStart() {
		return this.start;
	}

	public String getStartString() {
		return convertToString(this.start);
	}
	
	public String getEndString() {
		return convertToString(this.end);
	}

	public Date getEnd() {
		return this.end;
	}

	/***********************************MUTATORS*****************************/
	public void setFlag(boolean flag) {	
		this.flag = flag; 
	}

	public void setName(String name) {
		this.name = name;
	}

	public void setComplete() {
		this.status = TASK_STATUS.COMPLETED;
	}

	public void setStart(Date start) {
		if (start==null) {
			// convert to deadlined
			this.type = TASK_TYPE.DEADLINED;
			this.start = null;
		}
		else {
			if (this.start==null) {
				// convert to Event from Deadlined/Floating
				this.type = TASK_TYPE.EVENT;
			}
			this.start = start;
		}
	}

	public void setEnd(Date end) {
		if (end==null) {
			// convert to floating
			this.type = TASK_TYPE.FLOATING;
			this.end = null;
		}
		else {
			if (this.type==TASK_TYPE.FLOATING) {
				// if the task is a floating task
				this.type = TASK_TYPE.DEADLINED;
			}
			this.end = end;
			this.status = checkOverdue(end);
		}
	}

	public void setCategory(ArrayList<String> categories) {
		this.categories = categories;
	}
	
	public boolean deleteCategory(String category) {
		for (String string: this.categories) {
			if (string.equalsIgnoreCase(category)) {
				this.categories.remove(string);
				return true;
			}
		}
		return false;
	}
	
	public boolean addCategory(String category) {
		for (String string: this.categories) {
			if (string.equalsIgnoreCase(category)) {
				return false;
			}
		}
		this.categories.add(category);
		return true;
	}

	/*@Override
	public boolean equals(Object obj) {
		if (obj instanceof Task) {
			Task task = (Task) obj;
			return task==this;
		}
		else return false;
	}*/

	@Override
	public String toString() {
		return this.name;
	}
	
	public boolean update() {
		System.out.println("=====TASK===== updating " + this.name);
		switch (this.status) {
		case ONGOING:
			TASK_STATUS newStatus = this.checkOverdue(this.end);
			if (newStatus==TASK_STATUS.OVERDUE) {
				this.status = newStatus;
				return true;
			}
			break;
		case OVERDUE:
			newStatus = this.checkOverdue(this.end);
			if (newStatus==TASK_STATUS.ONGOING) {
				this.status = newStatus;
				return true;
			}
			break;
		}
		return false;
	}
	
	
	/********************************************INTERNAL*************************************/
	private TASK_STATUS checkOverdue(Date end) {
		Date current = new Date();
		System.out.println("=====TASK===== current: " + current);
		System.out.println("=====TASK===== end: " + end);
		if  (current.after(end)) {
			return TASK_STATUS.OVERDUE;
		}
		else {
			return TASK_STATUS.ONGOING;
		}
	}

	private String convertToString(Date date) {
		if (date==null) {
			return null;
		}
		
		String timeStr = timeFormatter.format(date);
		if (timeStr.equals("23:59:59")) {
			return dateFormater.format(date);
		}
		else {
			return datetimeFormater.format(date);
		}
	}
}
```
###### /src/Task/TASK_STATUS.java
``` java

public enum TASK_STATUS {
	ONGOING, FLOATING, COMPLETED, OVERDUE;
}
```
###### /src/Task/TASK_TYPE.java
``` java

public enum TASK_TYPE {
	DEADLINED, EVENT, FLOATING, INVALID;
}
```
###### /src/Test/SystemTest.java
``` java
import org.junit.Before;
import org.junit.Test;
import Logic.*;
import Task.*;
import java.util.*;

public class SystemTest {
	private static final String MESSAGE_INVALID_START_TIME = "Please enter a valid start time of the event.";
	private static final String MESSAGE_INVALID_END_TIME = "Please enter a valid end time of the task.";
	private static final String MESSAGE_INVALID_EVENT_TIME = "Please enter a valid start and end time of the event.";
	private static final String MESSAGE_INDEXOUTOFBOUND = "Please enter a valid index.";
	private static final String MESSAGE_EMPTY_LIST = "There is no task in this tab. Please add more tasks.";
	private static final String MESSAGE_UNSUCCESSFUL_SEARCH_TAG = "There is no tag named \"%1$s\".";
	private static final String MESSAGE_SUCCESSFUL_UNDO = "Undo successful.";
	private static final String MESSAGE_SUCCESSFUL_REDO = "Redo successful.";
	private static final String MESSAGE_SUCCESSFUL_SAVE = "Save successful.";
	private static final String MESSAGE_UNSUCCESSFUL_UNDO = "Undo not successful. There is nothing to undo";
	private static final String MESSAGE_UNSUCCESSFUL_REDO = "Redo not successful. There is nothing to redo";
	private static final String MESSAGE_SWITCH_VIEW = "Successfully switch to %1$s.";
	private static final String MESSAGE_INVALID_COMMAND = "Please enter a valid command.";
	private static final String MESSAGE_INVALID_COMPLETE = "Please enter a valid complete command.";
	private static final String MESSAGE_SUCCESSFUL_COMPLETE = 
			"Congratulation! Task(s) at \"%1$s\" is/are successfully completed. ";
	private static final String MESSAGE_UNSUCCESSFUL_COMPLETE = 
			"Task(s) at \"%1$s\" failed to complete due to its/their invalid index or already completed status. ";
	private static final String MESSAGE_INVALID_FLAG = "Please enter a valid flag command.";
	private static final String MESSAGE_SUCCESSFUL_FLAG = 
			"Task(s) at \"%1$s\" is/are successfully flagged. ";
	private static final String MESSAGE_UNSUCCESSFUL_FLAG = 
			"Task(s) at \"%1$s\" failed to flag due to its/their invalid index or already flagged/unflagged status. ";
	private static final String MESSAGE_SUCCESSFUL_UNFLAG =
			"Task(s) at \"%1$s\" is/are successfully unflagged. ";
	private static final String MESSAGE_UNSUCCESSFUL_UNFLAG = 
			"Task(s) at \"%1$s\" failed to unflag due to its/their invalid index or already flagged/unflagged status. ";
	private static final String MESSAGE_SUCCESSFUL_TAG = 
			"Task(s) \"%1$s\" is/are successfully tagged by \"%2$s\". ";
	private static final String MESSAGE_UNSUCCESSFUL_TAG = 
			"Task(s) \"%1$s\" failed to be tagged by \"%2$s\", because it has been already tagged before. ";
	private static final String MESSAGE_INVALID_EDIT = 
			"Please enter a valid edit.";
	private static final String MESSAGE_SUCCESSFUL_EDIT_NAME = 
			"Task name has been successfully edited to \"%1$s\".";
	private static final String MESSAGE_SUCCESSFUL_EDIT_START = 
			"Task start time has been successfully edited to \"%1$s\".";
	private static final String MESSAGE_SUCCESSFUL_EDIT_END = 
			"Task end time has been successfully edited to \"%1$s\".";
	private static final String MESSAGE_SUCCESSFUL_EDIT_EVENT = 
			"Task event time has been successfully edited to start from \"%1$s\" to \"%2$s\".";
	private static final String MESSAGE_SUCCESSFUL_EDIT_TAG = 
			"Tag name \"%1$s\" has been successfully edit to \"%2$s\".";
	private static final String MESSAGE_INVALID_DELETE = "Please enter a valid delete command.";
	private static final String MESSAGE_SUCCESSFUL_DELETE = "Task(s) at \"%1$s\" is/are successfully deleted. ";
	private static final String MESSAGE_SUCCESSFUL_DELETE_TAG = "Tag(s) \"%1$s\" are successfully deleted. ";
	private static final String MESSAGE_UNSUCCESSFUL_DELETE_TAG = "Tag(s) \"%1$s\" are not successfully deleted. ";
	private static final String MESSAGE_DELETE_ALL = "All tasks and tags are deleted.";
	private static final String MESSAGE_INVALID_SEARCH = "Please enter a valid search command.";
	private static final String MESSAGE_SUCCESSFUL_SEARCH_KEYWORD = "Search keyword \"%1$s\" is successful.";
	private static final String MESSAGE_SUCCESSFUL_SEARCH_TAG = "Search tag \"%1$s\" is successful.";
	private static final String MESSAGE_UNSUCCESSFUL_SEARCH_KEYWORD = "There is no task named \"%1$s\".";
	private Logic logic;
	private String actual;
	private String expected;

	@Before 
	public void setUp() { 
		logic = Logic.getInstance();
		logic.run("V0.5 Project Manual");
		logic.run("V0.5 Project Manual today");
		logic.run("V0.5 Project Manual by yesterday");
	}
	
	@After
	public void cleanUp() {
		logic.run("Delete all");
	}

	@Test
	public void testAdd() {
		// add a floating task
		this.actual = logic.run("V0.5 Project Manual");
		this.expected = "Task \"V0.5 Project Manual\" is added to FLOATING.";
		assertEquals(expected, actual);
		
		// add a deadlined task
		this.actual = logic.run("V0.5 Project Manual today");
		this.expected = "Task \"V0.5 Project Manual\" is added to ONGOING.";
		assertEquals(expected, actual);
		
		// add an overdue task
		this.actual = logic.run("V0.5 Project Manual by yesterday");
		this.expected = "Task \"V0.5 Project Manual\" is added to OVERDUE.";
		assertEquals(expected, actual);

		this.actual = logic.run("");
		this.expected = MESSAGE_INVALID_COMMAND;
		assertEquals(expected, actual);

		this.actual = logic.run("");
		this.expected = MESSAGE_INVALID_COMMAND;
		assertEquals(expected, actual);
	}
	
	@Test
	public void testEdit() {
		// edit task name
		this.actual = logic.run("Edit 3 V0.4 Project Manual");
		this.expected = "Task name has been successfully edited to \"V0.4 Project Manual\".";
		assertEquals(expected, actual);
		
		ArrayList<Task> floating = logic.getFloatingTasks();
		System.out.println(floating.size());
		Task task  = logic.getFloatingTasks().get(0);
		this.actual = task.getName();
		this.expected = "V0.4 Project Manual";
		assertEquals(expected, actual);
		
		// edit task deadlined
		this.actual = logic.run("Edit 1 by next Monday.");
		this.expected = "Task end time has been successfully edited to \"18/04/2016 18:00:00\".";
		assertEquals(expected, actual);
		
		// edit task event
		this.actual = logic.run("Edit 1 from today 2pm to 3pm.");
		this.expected = "Task event time has been successfully edited to start from \"11/04/2016 14:00:00\" to \"12/04/2016 15:00:00\".";
		assertEquals(expected, actual);
		
		this.actual = logic.run("Edit -1");
		this.expected = String.format(MESSAGE_INDEXOUTOFBOUND);
		assertEquals(expected, actual);
		
		this.actual = logic.run("edit");
		this.expected = String.format(MESSAGE_INVALID_COMMAND);
		assertEquals(expected, actual);
		
		this.actual = logic.run("edit edit");
		this.expected = String.format(MESSAGE_INDEXOUTOFBOUND);
		assertEquals(expected, actual);
	}
	
	@Test
	public void testDelete() {
		// delete task at 1 (V0.5 Project Manual) in All Tab
		this.actual = logic.run("Delete 1");
		this.expected = String.format("Task(s) at \"%1$s\" is/are successfully deleted. ", "[1]");
		assertEquals(expected, actual);
		
		// ERROR HANDLING
		this.actual = logic.run("Delete -1");
		this.expected = MESSAGE_INDEXOUTOFBOUND;
		assertEquals(expected, actual);
		
		// ERROR HANDLING
		this.actual = logic.run("Delete");
		this.expected = MESSAGE_INVALID_COMMAND;
		assertEquals(expected, actual);
		
		this.actual = logic.run("Delete all");
		this.expected = String.format("All tasks and tags are deleted.");
		assertEquals(expected, actual);
		
		// delete a task in empty All Tab
		this.actual = logic.run("Delete 1");
		this.expected = MESSAGE_EMPTY_LIST;
		assertEquals(expected, actual);		
	}
	
	@Test
	public void testComplete() {	
		// complete the task
		this.actual = logic.run("Complete 1");
		this.expected = String.format("Congratulation! Task(s) at \"%1$s\" is/are successfully completed. ", "[1]");
		assertEquals(expected, actual);
		
		Task task = this.logic.getCompletedTasks().get(0);
		this.actual = task.getStatus().toString();
		this.expected = "COMPLETED";
		assertEquals(expected, actual);
		
		// complete all tasks
		this.actual = logic.run("Complete all");
		this.expected = String.format(MESSAGE_SUCCESSFUL_COMPLETE, "[1, 2]") + "\n " + 
				String.format(MESSAGE_UNSUCCESSFUL_COMPLETE, "[0, 3]");
		assertEquals(expected, actual);
		
		// ERROR HANDLING
		this.actual = logic.run("Complete");
		this.expected = MESSAGE_INVALID_COMMAND;
		assertEquals(expected, actual);
		
		// ERROR HANDLING
		this.actual = logic.run("Complete complete");
		this.expected = MESSAGE_INVALID_COMMAND;
		assertEquals(expected, actual);
	}
	
	@Test
	public void testFlag() {
		this.actual = logic.run("Flag 1");
		this.expected = String.format(MESSAGE_SUCCESSFUL_FLAG, "[1]");
		assertEquals(expected, actual);
		
		this.actual = logic.run("Flag 1");
		this.expected = String.format(MESSAGE_UNSUCCESSFUL_FLAG, "[1]");
		assertEquals(expected, actual);
		
		this.actual = logic.run("Unflag 1");
		this.expected = String.format(MESSAGE_SUCCESSFUL_UNFLAG, "[1]");
		assertEquals(expected, actual);
		
		this.actual = logic.run("Unflag 1");
		this.expected = String.format(MESSAGE_UNSUCCESSFUL_UNFLAG, "[1]");
		assertEquals(expected, actual);
		
		this.actual = logic.run("flag");
		this.expected = String.format(MESSAGE_INVALID_COMMAND);
		assertEquals(expected, actual);
		
		this.actual = logic.run("Unflag");
		this.expected = String.format(MESSAGE_INVALID_COMMAND);
		assertEquals(expected, actual);
		
		this.actual = logic.run("Flag flag");
		this.expected = String.format(MESSAGE_INVALID_COMMAND);
		assertEquals(expected, actual);
	}
	
	@Test
	public void testTag() {
		this.actual = logic.run("tag 1 #important");
		this.expected = String.format(MESSAGE_SUCCESSFUL_TAG, "V0.5 Project Manual", "[important]");
		assertEquals(expected, actual);
		
		this.actual = logic.run("tag 1 #IMPORTant");
		this.expected = String.format(MESSAGE_UNSUCCESSFUL_TAG, "V0.5 Project Manual", "[IMPORTant]");
		assertEquals(expected, actual);
		
		this.actual = logic.run("tag");
		this.expected = String.format(MESSAGE_INVALID_COMMAND);
		assertEquals(expected, actual);
		
		this.actual = logic.run("tag -1");
		this.expected = String.format(MESSAGE_INDEXOUTOFBOUND);
		
		this.actual = logic.run("tag tag");
		this.expected = String.format(MESSAGE_INVALID_COMMAND);
		assertEquals(expected, actual);
		
		this.actual = logic.run("edit #important to #superImpt");
		this.expected = String.format(MESSAGE_SUCCESSFUL_EDIT_TAG, "important", "superImpt");
		assertEquals(expected, actual);
		
		this.actual = logic.run("delete #superImpt");
		this.expected = String.format(MESSAGE_SUCCESSFUL_DELETE_TAG, "[superImpt]");
		assertEquals(expected, actual);
	}
	
	@Test
	public void testSearch() {
		this.actual = logic.run("search manual");
		this.expected = String.format(MESSAGE_SUCCESSFUL_SEARCH_KEYWORD, "manual");
		assertEquals(expected, actual);
		
		this.actual = logic.getSearchResults().get(0).getName();
		this.expected = "V0.5 Project Manual";
		assertEquals(expected, actual);
		
		logic.run("tag 1 #important");
		this.actual = logic.run("search #important");
		this.expected = String.format(MESSAGE_SUCCESSFUL_SEARCH_TAG, "important");
		assertEquals(expected, actual);
		
		this.actual = logic.getSearchResults().get(0).getName();
		this.expected = "V0.5 Project Manual";
		assertEquals(expected, actual);
		
		this.actual = logic.run("search");
		this.expected = String.format(MESSAGE_INVALID_COMMAND);
		assertEquals(expected, actual);
		
		this.actual = logic.run("search -1");
		this.expected = String.format(MESSAGE_INVALID_SEARCH);
		assertEquals(expected, actual);
	}
}
```
