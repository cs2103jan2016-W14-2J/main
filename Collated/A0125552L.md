# A0125552L
###### /src/Command/DELETE_TYPE.java
``` java
package Command;

public enum DELETE_TYPE {
	SINGLE_INDEX, SINGLE_TAG, MULTIPLE_INDEXES, MULTIPLE_TAGS, RANGE_INDEXES, ALL_INDEXES, ALL_TAGS,
	START_DATE, END_DATE, INVALID;
}
```
###### /src/Command/EDIT_TYPE.java
``` java
package Command;

public enum EDIT_TYPE {
	TASK_NAME, EVENT_TIME, END_TIME, START_TIME, DEADLINED, INVALID, TAG;
}
```
###### /src/Command/FLAGANDCOMPLETE_TYPE.java
``` java
package Command;

public enum FLAGANDCOMPLETE_TYPE {
	SINGLE, MULTIPLE, RANGE, ALL, INVALID;
}
```
###### /src/Command/SEARCH_TYPE.java
``` java
package Command;

public enum SEARCH_TYPE {
	BY_DATE, BY_TASK, BY_TAG, INVALID
}
```
###### /src/Command/SORT_TYPE.java
``` java
package Command;

public enum SORT_TYPE {
	BY_DATE, BY_ASCENDING, BY_DESCENDING, INVALID;
}
```
###### /src/Logger/LoggerFile.java
``` java
package Logger;

import java.io.IOException;
import java.util.logging.ConsoleHandler;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;

public class LoggerFile {
	
	// Constants
	private static final String DODO_LOG_FILE = "DoDo.log";
	private static final String LOGGER_NAME = "logFile";
	private static final Level LVL_LOG_CONSOLE_LVL = Level.INFO;
	private static final Level LVL_LOG_LVL = Level.ALL;
	
	// Initialization
	private static FileHandler fileHandler;
	private static ConsoleHandler consoleHandler;
	private static LoggerFile instance = null;
	private static Logger logger;

	public static Logger getLogger() {
		
		if(instance == null) {
			instance = new LoggerFile();
		}
		
		return logger;
	}
	
	private LoggerFile() {
		
		try {	
			setUpLogger();
			setUpFileHandler();
			setUpConsoleHandler();
		}
		catch(SecurityException e) {
			e.printStackTrace();
		}
		catch(IOException e) {
			e.printStackTrace();
		}
	}
	
	private void setUpLogger() {
		logger = Logger.getLogger(LOGGER_NAME);
		logger.setLevel(LVL_LOG_LVL);
		logger.setUseParentHandlers(false);
	}
	
	private void setUpFileHandler() throws IOException {
		fileHandler = new FileHandler(DODO_LOG_FILE);
		logger.addHandler(fileHandler);
	}
	
	private void setUpConsoleHandler() {
		consoleHandler = new ConsoleHandler();
		consoleHandler.setLevel(LVL_LOG_CONSOLE_LVL);
		logger.addHandler(consoleHandler);
	}
}
```
###### /src/Parser/AddParser.java
``` java
package Parser;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.ocpsoft.prettytime.nlp.PrettyTimeParser;
import org.ocpsoft.prettytime.shade.org.apache.commons.lang.time.DateUtils;

import Task.*;
import Logger.*;

public class AddParser {
	
	private static Logger logger;
	
	// Prepositions
	private static final String KEYWORD_FROM = "from";
	private static final String KEYWORD_TO = "to";
	private static final String KEYWORD_ON = "on";
	private static final String KEYWORD_BY = " by ";
	private static final String KEYWORD_BY_1 = "by";
	private static final String KEYWORD_AT = "at";
	private static final String KEYWORD_BEFORE = "before";
	private static final String KEYWORD_IN = "in";
	private static final String KEYWORD_DUE = "due";
	
	// Positions of prepositions in a string
	private int LAST_POSITION_OF_FROM = -1;
	private int LAST_POSITION_OF_TO = -1;
	private int LAST_POSITION_OF_ON = -1;
	private int LAST_POSITION_OF_AT = -1;
	private int LAST_POSITION_OF_BEFORE = -1;
	private int LAST_POSITION_OF_BY = -1;
	private int LAST_POSITION_OF_IN = -1;
	
	// Constants
	private static final String STRING_SPLITTER = "\\s+";
	private static final String STRING_MIDNIGHT_TIME = "0000hrs";
	private static final String STRING_SPACING = " ";
	private static final String STRING_EMPTY = "";
	
	private int currentPosition = 0;
	private String contentOfPreposition = "";
	private String confirmTaskName = "";
	private String taskName = "";
	private String contentToAnalyse;
	private boolean hasTimeDateElement;
	private TASK_TYPE taskType;
	private Date date;
	private DateTimeParser dt;
	
	private ArrayList<String> taskItems;
	private ArrayList<String> preposition;
	private ArrayList<String> inputElements;
	private ArrayList<String> str;
	
	// Logging for processing task types.
	private static final String LOGGER_MESSAGE_DEADLINE_TYPE = "Processing deadline task.";
	private static final String LOGGER_MESSAGE_FLOATING_TYPE = "Processing floating task.";
	private static final String LOGGER_MESSAGE_EVENT_TYPE = "Processing event task.";
	
	// Logging for processing methods.
	private static final String LOGGER_MESSAGE_EXECUTE_ADD_PARSER = "AddParser Class: Processing executeAddParser method.";
	private static final String LOGGER_MESSAGE_EXIT_CLASS = "AddParser Class: Exiting AddParser class.";
	private static final String LOGGER_MESSAGE_DETERMINE_TASK_TYPE = "AddParser Class: Determining task type.";
	private static final String LOGGER_MESSAGE_CHECK_IF_EVENT_TASK = "AddParser Class: Checking if input is event task.";
	private static final String LOGGER_MESSAGE_CHECK_IF_FLOATING_TASK = "AddParser Class: Checking if input is floating task.";
	private static final String LOGGER_MESSAGE_CHECK_IF_DEADLINE_TASK = "AddParser Class: Checking if input is deadline task.";
	private static final String LOGGER_MESSAGE_PARSE_EVENT = "AddParser Class: Processing event task.";
	private static final String LOGGER_MESSAGE_PARSE_DEADLINED = "AddParser Class: Processing deadline task.";
	private static final String LOGGER_MESSAGE_PARSE_FLOATING = "AddParser Class: Processing floating task.";
	private static final String LOGGER_MESSAGE_GET_KEYWORD_POSITION = "AddParser Class: Getting position of preposition.";
	private static final String LOGGER_MESSAGE_CONVERT_ARRAYLIST_TO_LOWERCASE = "AddParser Class: Converting arraylist to lowercase.";
	private static final String LOGGER_MESSAGE_SET_EVENT_TIME = "AddParser Class: Setting time elements for event task.";
	private static final String LOGGER_MESSAGE_SET_DEADLINE = "AddParser Class: Setting time element for deadline task.";
	private static final String LOGGER_MESSAGE_EXTRACT_DATE_FROM_TASK = "AddParser Class: Extracting date elements from task name";
	private static final String LOGGER_MESSAGE_EXTRACT_PREPOSITION = "AddParser Class: Extracting preposition.";
	private static final String LOGGER_MESSAGE_GET_TASK_NAME = "AddParser Class: Extracting task name.";
	private static final String LOGGER_MESSAGE_FINAL_VERIFICATION = "AddParser Class: Checking if task name is really floating task.";
	private static final String LOGGER_MESSAGE_EXTRACT_LAST_PREPOSITION = "AddParser Class: Extracting last string.";
	private static final String LOGGER_MESSAGE_HAS_LAST_WORD_AS_PREPOSITION = "AddParser Class: Checking if last string is a preposition";
	
	public AddParser() {
		
		date = new Date();
		dt = new DateTimeParser();
		str = new ArrayList<String>();
		logger = LoggerFile.getLogger();
		preposition = new ArrayList<>(Arrays.asList("on", "at", "by", "before", "in"));
	
	}
	
	/*
	 * This method analyses the task type of an input and extract the
	 * information of the input.
	 * 
	 * @param commandUtil {@code CommandUtils} and userInput {@code String}
	 * 
	 * @return {@code CommandUtils} with attributes of the add command set to 
	 * CommandUtils object.
	 * 
	 */
	
	protected CommandUtils executeAddParser(CommandUtils commandUtil, String userInput) {
		
		assert (userInput != null);
		logger.log(Level.INFO, LOGGER_MESSAGE_EXECUTE_ADD_PARSER);
		
		String[] str = userInput.split(STRING_SPLITTER);
		taskItems = new ArrayList<String>(Arrays.asList(str));
		
		taskName = dt.checkForAbbreviation(taskItems);
		taskName = dt.checkAndConvertDateElement(taskItems);
		
		commandUtil = determineTaskType(commandUtil, taskItems, taskName);
		taskType = commandUtil.getType();
		
		logger.log(Level.INFO, LOGGER_MESSAGE_EXIT_CLASS);
		return analyseTaskType(commandUtil);
	}

	/*
	 * This method extracts the information of the input according to its 
	 * task type.
	 * 
	 * @param commandUtil {@code CommandUtils}
	 * 
	 * @return {@code CommandUtils} with attributes of the add command set to 
	 * CommandUtils object.
	 * 
	 */
	
	private CommandUtils analyseTaskType(CommandUtils commandUtil) {
		
		switch(taskType) {
		
			case DEADLINED:
				logger.log(Level.INFO, LOGGER_MESSAGE_DEADLINE_TYPE);
				commandUtil = parseDEADLINED(commandUtil, taskName);
				return parseFloating(taskItems, commandUtil.getName(), commandUtil);
			
			case FLOATING:
				logger.log(Level.INFO, LOGGER_MESSAGE_FLOATING_TYPE);
				return parseFloating(taskItems, taskName, commandUtil);
			
			case EVENT:
				logger.log(Level.INFO, LOGGER_MESSAGE_EVENT_TYPE);
				commandUtil = parseEVENT(commandUtil, taskName);
				return parseFloating(taskItems, commandUtil.getName(), commandUtil);
			
			default:
				break;
		}
		
		return commandUtil;
	}

	/*
	 * This method analyses and determines the task type of a user input.
	 * 
	 * @param commandUtil {@code CommandUtils}, taskItems {@code List<E>}
	 * 		  and taskName {@code String}
	 * 
	 * @return {@code CommandUtils} with the task type set to CommandUtils object.
	 * 
	 */
	
	public CommandUtils determineTaskType(CommandUtils commandUtil, ArrayList<String> taskItems, String taskName) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_DETERMINE_TASK_TYPE);
		
		if (checkIfDeadlinedTask(taskItems, taskName)) {
			commandUtil.setTaskType(TASK_TYPE.DEADLINED);
		}
		else if (checkIfEventTask(taskName)) {
			commandUtil.setTaskType(TASK_TYPE.EVENT);
		}
		else if (checkIfFloatingTask(taskItems, taskName)) {
			commandUtil.setTaskType(TASK_TYPE.FLOATING);
		}
		else {
			commandUtil.setTaskType(TASK_TYPE.INVALID);
		}
		return commandUtil;
	}
	
	/*
	 * This method analyses and verifies if a user input is an event task.
	 * 
	 * @param taskName {@code String}
	 * 
	 * @return {@code boolean} 
	 * 
	 */
	private boolean checkIfEventTask(String taskName) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_CHECK_IF_EVENT_TASK);
		
		LAST_POSITION_OF_FROM = taskName.toLowerCase().lastIndexOf(KEYWORD_FROM);
		LAST_POSITION_OF_TO = taskName.toLowerCase().lastIndexOf(KEYWORD_TO);

		// Example: study from <startDate> to <endDate>
		if (LAST_POSITION_OF_FROM < LAST_POSITION_OF_TO && LAST_POSITION_OF_FROM != -1) {
			return (dt.checkForDateAndTime(taskName, LAST_POSITION_OF_FROM, LAST_POSITION_OF_TO)) 
					? true : false;
		}
		// Example: play DOTA from 7pm
		else if (LAST_POSITION_OF_FROM > LAST_POSITION_OF_TO) {
			return (dt.checkForDateAndTime(taskName, LAST_POSITION_OF_FROM, taskName.length())) 
					? true : false;
		}
		else {
			return false;
		}
	}
	
	/*
	 * This method analyses and verifies if a user input is a floating task.
	 * 
	 * @param taskItems {@code List<E>} and taskName {@code String}
	 * 
	 * @return {@code boolean} 
	 * 
	 */
	private boolean checkIfFloatingTask(ArrayList<String> taskItems, String taskName) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_CHECK_IF_FLOATING_TASK);
		return (!checkIfEventTask(taskName) && !checkIfDeadlinedTask(taskItems, taskName)) ? true : false;
	
	}
	
	/*
	 * This method analyses and verifies if a user input is a deadlined task.
	 * 
	 * @param taskItems {@code List<E>} and taskName {@code String}
	 * 
	 * @return {@code boolean} 
	 * 
	 */
	
	private boolean checkIfDeadlinedTask(ArrayList<String> taskItems, String taskName) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_CHECK_IF_DEADLINE_TASK);
		getKeywordPosition(taskName);
		
		return ((LAST_POSITION_OF_AT != -1 || LAST_POSITION_OF_ON != -1 || 
				 LAST_POSITION_OF_BEFORE != -1 || LAST_POSITION_OF_BY != -1 || 
				 LAST_POSITION_OF_IN != -1) && (LAST_POSITION_OF_FROM == -1 && 
				 LAST_POSITION_OF_TO == -1)) ? true : false;
	}
	
	/*
	 * This method extracts the start time, end time and task name from an
	 * event task.
	 * 
	 * @param commandUtil {@code CommandUtils} and taskName {@code String}
	 * 
	 * @return {@code CommandUtils} 
	 * 
	 */
	
	private CommandUtils parseEVENT(CommandUtils commandUtil, String taskName) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_PARSE_EVENT);
		
		// Add prepositions for determining an event task to ArrayList<String> preposition.
		String[] elements = taskName.split(STRING_SPLITTER);
		preposition.add(KEYWORD_FROM);
		preposition.add(KEYWORD_TO);
		
		// Store string split taskName into ArrayList<String>
		inputElements = new ArrayList<String>(Arrays.asList(elements));
		
		// Separate task name from date elements.
		confirmTaskName = getPossibleTaskName(currentPosition, confirmTaskName, inputElements);
		confirmTaskName = dt.extractDate(confirmTaskName) + STRING_SPACING;
		contentToAnalyse = dt.getDateElements() + STRING_SPACING;
		str = extractInputWithPreposition(currentPosition, contentOfPreposition, str);
		
		extractDateFromTask();
		return setEventTime(commandUtil, taskName, date);
	}
	
	/*
	 * This method extracts the end time and task name from a deadline
	 * task.
	 * 
	 * @param commandUtil {@code CommandUtils} and taskName {@code String}
	 * 
	 * @return {@code CommandUtils} 
	 * 
	 */
	
	private CommandUtils parseDEADLINED(CommandUtils commandUtil, String taskName) {

		logger.log(Level.INFO, LOGGER_MESSAGE_PARSE_DEADLINED);
		
		String[] elements = taskName.split(STRING_SPLITTER);
		inputElements = new ArrayList<String>(Arrays.asList(elements));
		
		confirmTaskName = getPossibleTaskName(currentPosition, confirmTaskName, inputElements);
		confirmTaskName = dt.extractDate(confirmTaskName) + STRING_SPACING;
		contentToAnalyse = dt.getDateElements() + STRING_SPACING;
		System.out.println("parseDeadline : " + contentToAnalyse);
		str = extractInputWithPreposition(currentPosition, contentOfPreposition, str);
		
		extractDateFromTask();
		return setDeadLine(commandUtil, confirmTaskName, date);
	}
	
	/*
	 * This method verifies if the user input contains end time and extract
	 * the task name accordingly.
	 * 
	 * @param taskItems {@code List<E>}, commandUtil {@code CommandUtils} 
	 * 		  and taskName {@code String}
	 * 
	 * @return {@code CommandUtils} 
	 * 
	 */
	private CommandUtils parseFloating(ArrayList<String> taskItems, String taskName, CommandUtils commandUtil) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_PARSE_FLOATING);
		
		hasTimeDateElement = dt.hasDateAndTimeElements(taskName);
		List<Date> dates = new PrettyTimeParser().parse(taskName);
		
		if (dates.size() == 0 && dt.getDateElements() == null) {
			commandUtil.setTaskName(taskName);
		}
		else {
			
			// Example: Meet Hannah Tomorrow. (no preposition)
			if (dates.size() == 1 && hasTimeDateElement == true) {		
			
				commandUtil.setEndTime(dt.checkAndSetDefaultEndTime(dates.get(0), date));
				commandUtil = finalVerification(taskName, commandUtil);	
			}
			
			// Example: Hackathon today to 05.05.16
			else if (dates.size() > 1 && hasTimeDateElement == true) {
				
				commandUtil.setEndTime(dt.checkAndSetDefaultEndTime(dates.get(1), date));
				commandUtil.setStartTime(dates.get(0));
				commandUtil.setTaskType(TASK_TYPE.EVENT);
			}
			
			// Meet Hannah at Hackathon
			else if (hasTimeDateElement == false) {
				commandUtil.setTaskName(taskName);	
			}
		}
		
		return commandUtil;
	}
	
	/*
	 * This method identifies the position of the prepositions in a user input
	 * 
	 * @param taskName {@code String}
	 * 
	 * @return {} 
	 * 
	 */
	
	private void getKeywordPosition(String taskName) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_GET_KEYWORD_POSITION);
		ArrayList<String> temp = new ArrayList<String>(convertArrayListToLowerCase(taskName));
		
		LAST_POSITION_OF_AT = temp.lastIndexOf(KEYWORD_AT);
		LAST_POSITION_OF_ON = temp.lastIndexOf(KEYWORD_ON);
		LAST_POSITION_OF_BEFORE = temp.lastIndexOf(KEYWORD_BEFORE);
		LAST_POSITION_OF_BY = temp.lastIndexOf(KEYWORD_BY_1);
		LAST_POSITION_OF_FROM = temp.lastIndexOf(KEYWORD_FROM);
		LAST_POSITION_OF_TO = temp.lastIndexOf(KEYWORD_TO);
		LAST_POSITION_OF_IN = temp.lastIndexOf(KEYWORD_IN);
	
	}
	
	/*
	 * This method converts elements in an arraylist to lowercase.
	 * 
	 * @param taskName {@code String}
	 * 
	 * @return {@code List<E>} with all string in lowercase. 
	 * 
	 */
	private ArrayList<String> convertArrayListToLowerCase(String taskName) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_CONVERT_ARRAYLIST_TO_LOWERCASE);
		String[] str = taskName.toLowerCase().split(STRING_SPLITTER);
		ArrayList<String> temp = new ArrayList<String>(Arrays.asList(str));
		
		return temp;
	}
	
	/*
	 * This method extracts the time elements from an event task and set to CommandUtils
	 * object.
	 * 
	 * @param commandUtil {@code CommandUtils} , taskName {@code String} 
	 * 		  and date {@code Date}
	 * 
	 * @return {@code CommandUtils} 
	 * 
	 */
	
	private CommandUtils setEventTime(CommandUtils commandUtil, String taskName, Date date) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_SET_EVENT_TIME);
		
		List<Date> confirmDate = new PrettyTimeParser().parse(contentToAnalyse.replace(KEYWORD_FROM, STRING_SPACING));
		
		if (confirmDate.size() == 2) {
			
			commandUtil.setStartTime(dt.checkAndSetDefaultStartTime(confirmDate.get(0), date));
			commandUtil.setEndTime(dt.checkAndSetDefaultEndTime(confirmDate.get(1), date));
			commandUtil.setTaskName(confirmTaskName.trim());
		}
		else if (confirmDate.size() == 1) {
			
			commandUtil.setEndTime(dt.checkAndSetDefaultEndTime(confirmDate.get(0), date));
			commandUtil.setTaskName(confirmTaskName.trim());
			commandUtil.setTaskType(TASK_TYPE.DEADLINED);
		}
		else {
		
			commandUtil.setTaskType(TASK_TYPE.FLOATING);
		}
		
		return commandUtil;
	
	}
	
	/*
	 * This method extracts the time elements from an event task and set to CommandUtils
	 * object.
	 * 
	 * @param commandUtil {@code CommandUtils} , confirmTaskName {@code String} 
	 * 		  and date {@code Date}
	 * 
	 * @return {@code CommandUtils} 
	 * 
	 */

	private CommandUtils setDeadLine(CommandUtils commandUtil, String confirmTaskName, Date date) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_SET_DEADLINE);
		
		List<Date> confirmDate = new PrettyTimeParser().parse(contentToAnalyse.replace(KEYWORD_BY, STRING_SPACING));
		
		// Example: Meeting with boss at 6.30pm
		if (confirmDate.size() == 1 && !contentToAnalyse.contains(STRING_MIDNIGHT_TIME)) {
			commandUtil.setEndTime(dt.checkAndSetDefaultEndTime(confirmDate.get(0), date));
		}
		// Example: submit proposal to boss at 2400hrs.
		else if (confirmDate.size() == 1 && contentToAnalyse.contains(STRING_MIDNIGHT_TIME)) {
			commandUtil.setEndTime(dt.checkAndSetDefaultEndTime(DateUtils.addDays(confirmDate.get(0), 1), date));
		}
		else if (confirmDate.size() == 2) {
			commandUtil.setEndTime(dt.checkAndSetDefaultEndTime(confirmDate.get(1), date));
		}
		
		commandUtil.setTaskName(confirmTaskName.trim());
		
		if (confirmTaskName.trim().equals(taskName)) {
			commandUtil.setTaskType(TASK_TYPE.FLOATING);
		}
		
		return commandUtil;
	
	}
	
	/*
	 * This method extracts the time elements from a task 
	 * 
	 * @param {}
	 * 
	 * @return {} 
	 * 
	 */
	private void extractDateFromTask() {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_EXTRACT_DATE_FROM_TASK);
		
		for (int i = 0; i < str.size(); i++) {
			
			List<Date> dates = new PrettyTimeParser().parse(str.get(i));
			
			if (dates.size() != 0 && dt.hasDateAndTimeElements(str.get(i)) == true) {
				contentToAnalyse += str.get(i) + STRING_SPACING;
			}
			else {
				confirmTaskName += str.get(i) + STRING_SPACING;
			}
		}
	}
	
	/*
	 * This method extracts string starting from a preposition to the string 
	 * before the next preposition or the end of the user input.
	 * 
	 * @param currentPosition {@code int} , contentOfPreposition {@code String} 
	 * 		  and str {@code List<E>}
	 * 
	 * @return {@code List<E>}  
	 * 
	 */
	private ArrayList<String> extractInputWithPreposition(int currentPosition, String contentOfPreposition,
			ArrayList<String> str) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_EXTRACT_PREPOSITION);
		
		for (int i = 0; i < inputElements.size(); ) {
			
			contentOfPreposition += inputElements.get(currentPosition) + STRING_SPACING;
			inputElements.remove(currentPosition);
			
			while (inputElements.size() != 0) {
				
				if (!preposition.contains(inputElements.get(currentPosition))) {
					contentOfPreposition += inputElements.get(currentPosition) + STRING_SPACING;
					inputElements.remove(currentPosition);
				}
				else {
					break;
				}
			}
			
			str.add(contentOfPreposition.trim());
			contentOfPreposition = STRING_EMPTY;
		
		}
		
		return str;
	}
	
	/*
	 * This method extracts possible task name from the user input
	 * object.
	 * 
	 * @param currentPosition {@code int} , confirmTaskName {@code String} 
	 * 		  and inputElements {@code List<E>}
	 * 
	 * @return {@code String} with preposition and possible date elements removed. 
	 * 
	 */

	private String getPossibleTaskName(int currentPosition, String confirmTaskName, ArrayList<String> inputElements) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_GET_TASK_NAME);
		
		for (int i = 0; i < inputElements.size(); i++) {
			
			if (!preposition.contains(inputElements.get(currentPosition))) {
				confirmTaskName += inputElements.get(currentPosition) + STRING_SPACING; 
				inputElements.remove(currentPosition);
			}
			else {
				break;
			}
		}
		return confirmTaskName;
	}

	/*
	 * This method verifies if a floating task consists of date element.
	 * Example: tomorrow meet boss for meeting.
	 * 
	 * @param userTask {@code String} and commandUtil {@code CommandUtils}
	 * 
	 * @return {@code CommandUtils} 
	 * 
	 */
	
	private CommandUtils finalVerification(String userTask, CommandUtils commandUtil) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_FINAL_VERIFICATION);
		
		String temp = dt.extractDate(userTask);
		commandUtil.setTaskName(extractLastPreposition(temp));
		
		if (temp.trim().equals(userTask.trim())) {
			commandUtil.setTaskType(TASK_TYPE.FLOATING);
		}
		else {
			commandUtil.setTaskType(TASK_TYPE.DEADLINED);
		}
		
		return commandUtil;
	}
	
	/*
	 * This method checks if the last string in the task name consists of
	 * preposition and removes it if there is.
	 * 
	 * @param finalTaskName {@code String} 
	 * 
	 * @return {@code CommandUtils} 
	 * 
	 */

	private String extractLastPreposition(String finalTaskName) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_EXTRACT_LAST_PREPOSITION);
		
		String[] str = finalTaskName.split(STRING_SPLITTER);
		String newStr = STRING_EMPTY;
		int lastWordPosition = str.length - 1;
		
		if (isLastWordPreposition(str, lastWordPosition)) {
			str[lastWordPosition] = STRING_EMPTY;
		}

		return toStringArray(str, newStr).trim();
	}

	/*
	 * This method concatenates string array into string.
	 * 
	 * @param str {@code String[]} and newStr {@code String} 
	 * 
	 * @return {@code CommandUtils} 
	 * 
	 */

	private String toStringArray(String[] str, String newStr) {
		
		for (int i = 0; i < str.length; i++) {
			newStr += str[i] + STRING_SPACING;
		}
		
		return newStr;
	}
	
	/*
	 * This method checks if a string contains a preposition word 
	 * as its last word.
	 * 
	 * @param str {@code String[]} and lastWordPosition {@code int} 
	 * 
	 * @return {@code boolean} 
	 * 
	 */
	
	private boolean isLastWordPreposition (String[] str, int lastWordPosition) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_HAS_LAST_WORD_AS_PREPOSITION);
		
		return (str[lastWordPosition].toLowerCase().contains(KEYWORD_AT) || 
				str[lastWordPosition].toLowerCase().contains(KEYWORD_BY) ||
				str[lastWordPosition].toLowerCase().contains(KEYWORD_ON) ||
				str[lastWordPosition].toLowerCase().contains(KEYWORD_DUE) ||
				str[lastWordPosition].toLowerCase().contains(KEYWORD_TO)) 
				? true : false;
	}
	
}
```
###### /src/Parser/CommandUtils.java
``` java
package Parser;

import java.util.ArrayList;
import java.util.Date;

import Command.COMMAND_TYPE;
import Command.DELETE_TYPE;
import Command.EDIT_TYPE;
import Command.FLAGANDCOMPLETE_TYPE;
import Command.SEARCH_TYPE;
import Command.SORT_TYPE;
import Task.TASK_TYPE;

public class CommandUtils {
	
	private ArrayList<Integer> indexOfFlagAndMark;
	private ArrayList<String> tags;
	private ArrayList<String> tagToDelete;
	private ArrayList<Integer> indexToDelete;
	
	private Date startTime;
	private Date endTime;
	private Date searchByDate;
	
	private String oldTag;
	private String taskName;
	private String searchByTask;
	private String searchByTag;
	private int taskID;
	private boolean isImportant;
	
	private COMMAND_TYPE command;
	private TASK_TYPE taskType;
	private FLAGANDCOMPLETE_TYPE flagAndCompleteType;
	private SEARCH_TYPE searchType;
	private SORT_TYPE sortType;
	private EDIT_TYPE editType;
	private DELETE_TYPE deleteType;
	
	public CommandUtils () {
		
		indexOfFlagAndMark = new ArrayList<Integer>();
		tags = new ArrayList<String>();
		tagToDelete = new ArrayList<String> ();
		indexToDelete = new ArrayList<Integer>();
		
		startTime = null;
		endTime = null;
		searchByDate = null;
		
		oldTag = "";
		taskName = "";
		searchByTask = "";
		searchByTag = "";
		taskID = -1;
		isImportant = false;
		
		command = COMMAND_TYPE.INVALID;
		taskType = TASK_TYPE.INVALID;
		flagAndCompleteType = FLAGANDCOMPLETE_TYPE.INVALID;
		searchType = SEARCH_TYPE.INVALID;
		sortType = SORT_TYPE.INVALID;
		editType = EDIT_TYPE.INVALID;
		deleteType = DELETE_TYPE.INVALID;
		
	}
	//****************************************Common Mutators *****************************************//
	/*
	 * 
	 * @param {COMMAND_TPE}			
	 * 
	 */
	protected void setCommandType(COMMAND_TYPE command) {
		this.command = command;
	}
	
	/*
	 * 
	 * @param {Date}			
	 * 
	 */
	protected void setStartTime(Date startTime) {
		this.startTime = startTime;
	}
	
	/*
	 * 
	 * @param {Date}			
	 * 
	 */
	protected void setEndTime(Date endTime) {
		this.endTime = endTime;
	}

	/*
	 * 
	 * @param {String}			
	 * 
	 */
	protected void setTaskName(String taskName) {
		this.taskName = taskName;
	}
	
	/*
	 * 
	 * @param {TASK_TYPE}			
	 * 
	 */
	protected void setTaskType(TASK_TYPE taskType) {
		this.taskType = taskType;
	}
	
	/*
	 * 
	 * @param {ArrayList<String>}			
	 * 
	 */
	protected void setTaskTag(ArrayList<String> tags) {
		this.tags = tags;
	}
	
	/*
	 * 
	 * @param {String}			
	 * 
	 */
	protected void setTaskID(String index) {
		this.taskID = Integer.parseInt(index);
	}
	//***********************************Accessors for AddParser************************************//
	
	/*
	 * Returns the start time of a task.
	 * 
	 * @param {}
	 * 
	 * @return {@code Date} 
	 * 			
	 * 
	 */
	public Date getStartTime() {
		return this.startTime;
	}
	
	/*
	 * Returns the end time of a task.
	 * 
	 * @param {}
	 * 
	 * @return {@code Date} 
	 * 			
	 * 
	 */
	public Date getEndTime() {
		return this.endTime;
	}
	
	/*
	 * Returns the name without the start & end time of a task.
	 * 
	 * @param {}
	 * 
	 * @return {@code String} 
	 * 			
	 * 
	 */
	public String getName() {
		return this.taskName;
	}
	
	/*
	 * Returns the type of a task.
	 * 
	 * @param {}
	 * 
	 * @return {@code enum} 
	 * 			
	 * 
	 */
	
	public TASK_TYPE getType() {
		return this.taskType;
	}
	
	/*
	 * Returns the type of a command.
	 * 
	 * @param {}
	 * 
	 * @return {@code enum} 
	 * 			
	 * 
	 */
	
	public COMMAND_TYPE getCommandType() {
		return this.command;
	}
	
	/*
	 * 
	 * @param {boolean}			
	 * 
	 */
	protected void setTaskImportance(boolean isImportant) {
		this.isImportant = isImportant;
	}
	
	/*
	 * Returns the importance of a task.
	 * 
	 * @param {}
	 * 
	 * @return {@code boolean} 
	 * 			
	 * 
	 */
	
	public boolean getImportance() {
		return this.isImportant;
	}

	/*
	 * Returns the list of tags assigned to a task.
	 * 
	 * @param {}
	 * 
	 * @return {@code List<E>} 
	 * 			
	 * 
	 */
	
	public ArrayList<String> getTag() {
		return this.tags;
	}
	
		//********************************** Mutators and Accessors for DeleteParser ********************************//
	
	/*
	 * Returns the type of deletion.
	 * 
	 * @param {}
	 * 
	 * @return {@code enum} 
	 * 			
	 * 
	 */
	
	public DELETE_TYPE getDeleteType() {
		return this.deleteType;
	}
	/*
	 * 
	 * @param {DELETE_TYPE}			
	 * 
	 */
	
	protected void setDeleteType(DELETE_TYPE deleteType) {
		this.deleteType = deleteType;
	}
	/*
	 * 
	 * @param {ArrayList<String>}			
	 * 
	 */
	protected void setTagToDelete(ArrayList<String> tagToDelete) {
		this.tagToDelete = tagToDelete;
	}
	
	/*
	 * Returns the list of tags to delete.
	 * 
	 * @param {}
	 * 
	 * @return {@code List<E>} 
	 * 			
	 * 
	 */
	public ArrayList<String> getTagToDelete() {
		return this.tagToDelete;
	}
	/*
	 * 
	 * @param {ArrayList<String>}			
	 * 
	 */
	
	protected void setIndexToDelete(ArrayList<Integer> indexToDelete) {
		this.indexToDelete = indexToDelete;
	}
	
	/*
	 * Returns the list of indexes to delete.
	 * 
	 * @param {}
	 * 
	 * @return {@code List<E>} 
	 * 			
	 * 
	 */
	
	public ArrayList<Integer> getIndexToDelete() {
		return this.indexToDelete;
	}
	
	//********************************** Mutators and Accessors for EditParser************************************//
	
	/*
	 * Returns the index of a task.
	 * 
	 * @param {}
	 * 
	 * @return {@code int} 
	 * 			
	 * 
	 */
	public int getTaskID() {
		return this.taskID;
	}
	
	/*
	 * 
	 * @param {EDIT_TYPE}			
	 * 
	 */
	protected void setEditType(EDIT_TYPE editType) {
		this.editType = editType;
	}
	
	/*
	 * Returns the type of edits.
	 * 
	 * @param {}
	 * 
	 * @return {@code enum} 
	 * 			
	 * 
	 */
	public EDIT_TYPE getEditType() {
		return this.editType;
	}
	/*
	 * 
	 * @param {String}			
	 * 
	 */
	protected void setOldTag(String oldTag) {
		this.oldTag = oldTag;
	}
	
	/*
	 * Returns the tag to be replaced.
	 * 
	 * @param {}
	 * 
	 * @return {@code String} 
	 * 			
	 * 
	 */
	public String getOldTag() {
		return this.oldTag;
	}
	
	//**************************** Mutators and Accessors for Flag/Unflag/CompleteParser ***********************//
	
	/*
	 * 
	 * @param {FLAGANDCOMPLETE_TYPE}			
	 * 
	 */
	protected void setFlagCompleteType(FLAGANDCOMPLETE_TYPE flagAndCompleteType) {
		this.flagAndCompleteType = flagAndCompleteType;
	}
	/*
	 * 
	 * @param {ArrayList<Integer>}			
	 * 
	 */
	protected void setTaskToFlagAndMark(ArrayList<Integer> indexOfFlagAndMark) {
		this.indexOfFlagAndMark = indexOfFlagAndMark;
	}
	
	/*
	 * Returns the type of flagging / completion.
	 * 
	 * @param {}
	 * 
	 * @return {@code enum} 
	 * 			
	 * 
	 */
	public FLAGANDCOMPLETE_TYPE getFlagAndCompleteType() {
		return this.flagAndCompleteType;
	}
		
	/*
	 * Returns the list of indexes to flag/ complete.
	 * 
	 * @param {}
	 * 
	 * @return {@code List<E>} 
	 * 			
	 * 
	 */
	public ArrayList<Integer> getTaskToFlagAndMark() {
		return this.indexOfFlagAndMark;
	}
	//***************************** Mutators and Accessors for SearchParser ************************************//
	/*
	 * 
	 * @param {SEARCH_TYPE}			
	 * 
	 */
	protected void setSearchType (SEARCH_TYPE searchType) {
		this.searchType = searchType;
	}
	/*
	 * 
	 * @param {Date}			
	 * 
	 */
	protected void setSearchByDate (Date searchByDate) {
		this.searchByDate = searchByDate;
	}
	
	/*
	 * 
	 * @param {String}			
	 * 
	 */
	protected void setSearchByTag(String searchByTag) {
		this.searchByTag = searchByTag;
	}
	
	/*
	 * Returns the type of search made.
	 * 
	 * @param {}
	 * 
	 * @return {@code enum} 
	 * 			
	 * 
	 */
	public SEARCH_TYPE getSearchType() {
		return this.searchType;
	}
	
	protected void setSearchByTask(String searchByTask) {
		this.searchByTask = searchByTask;
	}
	
	/*
	 * Returns the string to be searched.
	 * 
	 * @param {}
	 * 
	 * @return {@code String} 
	 * 			
	 * 
	 */
	
	public String getSearchByTask() {
		return this.searchByTask.trim();
	}
	
	/*
	 * Returns the tag to search.
	 * 
	 * @param {}
	 * 
	 * @return {@code String} 
	 * 			
	 * 
	 */
	
	public String getSearchByTag() {
		return this.searchByTag.trim();
	}
	
	/*
	 * Returns the date to search.
	 * 
	 * @param {}
	 * 
	 * @return {@code Date} 
	 * 			
	 * 
	 */
	public Date getSearchByDate() {
		return this.searchByDate;
	}
	
	//******************************** Mutators and Accessors for SortParser ************************************//
	

	/*
	 *  Returns the type of sort.
	 * 
	 * @param {}
	 * 
	 * @return sort Type
	 * 			
	 * 
	 */
	public SORT_TYPE getSortType() {
		return this.sortType;
	}
	/*
	 * 
	 * @param {SORT_TYPE}			
	 * 
	 */
	protected void setSortType(SORT_TYPE sortType) {
		this.sortType = sortType;
	}
	
}
```
###### /src/Parser/DateTimeParser.java
``` java
package Parser;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.ocpsoft.prettytime.nlp.PrettyTimeParser;

import Logger.LoggerFile;

public class DateTimeParser {
	
	public enum DATE_TYPES {
		TYPE_THIS_COMING_WEEKDAY, TYPE_NEXT_WEEK, TYPE_NEXT_WEEKDAY, TYPE_TOMORROW, TYPE_TODAY, TYPE_THE_DAY_AFTER_TOMORROW,
		TYPE_NEXT_FEW_DAYS, TYPE_DATE, TYPE_TIME, TYPE_NULL
	};
	
	private static Logger logger;
	
	private List<String> todayTypes;
	private List<String> tomorrowTypes;
	private ArrayList <String> taskItems;
	private ArrayList<String> dayTypes;
	private ArrayList<String> monthTypes;
	private ArrayList<String> preposition;
	
	private String confirmTaskName = "";
	private String possibleDate = "";
	private Date newDate;
	private SimpleDateFormat sf;
	private SimpleDateFormat sdf;
	private DateFormat df;
	
	// String constants.
	private final static String KEYWORD_AM = "am";
	private final static String KEYWORD_PM = "pm";
	private final static String KEYWORD_HRS = "hrs";
	private final static String KEYWORD_HR = "hr";
	private final static String KEYWORD_THE_DAY_AFTER_TOMORROW = " the day after tomorrow";
	private final static String KEYWORD_DAY_AFTER_TOMORROW = " day after tomorrow";
	private final static String KEYWORD_TOMORROW_1 = "tomorrow";
	private final static String KEYWORD_TOMORROW_2 = "tomorrow ";
	private final static String KEYWORD_YESTERDAY_SHORTFORM = "ytd";
	private final static String KEYWORD_YESTERDAY = "yesterday";
	private final static String KEYWORD_TODAY = "today";
	private final static String KEYWORD_COMING = "coming";
	private final static String KEYWORD_THIS_COMING = " this coming";
	private final static String KEYWORD_AT_1 = "at";
	private final static String KEYWORD_AT_2 = "@";
	private final static String KEYWORD_HASH_TAG = "#";
	private final static String KEYWORD_THE = " the ";
	private final static String KEYWORD_DAYS = "days";
	private final static String KEYWORD_NEXT_1 = "next";
	private final static String KEYWORD_NEXT_WEEK = " next week";
	private final static String KEYWORD_NEXT_WEEK_2 = "next week";
	
	private final static String STRING_EMPTY = "";
	private final static String STRING_SPACING = " ";
	private final static String STRING_SLASH = "/";
	private final static String STRING_HOLIDAY_VALENTINES_DAY = "valentine's day";
	private final static String STRING_HOLIDAY_CHRISTMAS = "christmas";
	private final static String STRING_HOLIDAY_NEW_YEAR = "new year's";
	private final static String STRING_HOLIDAY_NEW_YEAR_EVE = "new year's eve";
	private final static String STRING_HOLIDAY_HALLOWEEN = "halloween";
	private final static String STRING_HOLIDAY_MOTHERS_DAY = "mother's day";
	private final static String STRING_HOLIDAY_FATHERS_DAY = "father's day";
	private final static String STRING_SPLITTER = "\\s+";
	private final static String PUNCTUATION_REMOVER = "[.-/]";

	// Date constants
	private final static String DEFAULT_TIME_6PM = "18:00:00";
	private final static String DEFAULT_TIME_1159PM = "23:59:59";
	private final static String DEFAULT_TIME_2400HRS = "2400hrs";
	private final static String DEFAULT_TIME_0000HRS = "0000hrs";
	private final static String DEFAULT_TIME_000000 = "00:00:00";
	private final static String DATE_FORMAT_1 = "dd/MM/yyyy";
	private final static String DATE_FORMAT_2 = "yyyy/MM/dd";
	private final static String DATE_FORMAT_3 = "dd.MM.yyyy";
	private final static String DATE_FORMAT_4 ="dd-MM-yyyy";
	private final static String DATE_FORMAT_WITH_TIME = "dd/MM/yyyy HH:mm:ss";
	private final static String TIME_WITHOUT_DATE_FORMAT = "HH:mm";
	
	private final static int NUM_MAX_DAYS_PER_MONTH = 31;
	private final static int NUM_MAX_MONTH_PER_YEAR = 12;

	// Logging messages for processing DateAndTimeParser methods
	private static final String LOGGER_MESSAGE_REMOVE_THE_DAY_AFTER_TOMORROW = "DateAndTimeParser class : Removing the day after tomorrow.";
	private static final String LOGGER_MESSAGE_REMOVE_TOMORROW = "DateAndTimeParser class : Removing tomorrow.";
	private static final String LOGGER_MESSAGE_REMOVE_YESTERDAY = "DateAndTimeParser class : Removing yesterday.";
	private static final String LOGGER_MESSAGE_REMOVE_TODAY = "DateAndTimeParser class : Removing today.";
	private static final String LOGGER_MESSAGE_REMOVE_THIS_COMING_WEEKDAY = "DateAndTimeParser class : Removing this coming weekday.";
	private static final String LOGGER_MESSAGE_REMOVE_NEXT_FEW_DAYS = "DateAndTimeParser class : Removing next few days.";
	private static final String NULL_POINTER_EXCEPTION = "DateAndTimeParser class : May receive null pointer exception.";
	private static final String LOGGER_MESSAGE_REMOVE_NUMERICAL_DATE = "DateAndTimeParser class : Removing numerical date.";
	private static final String LOGGER_MESSAGE_REMOVE_NEXT_WEEK = "DateAndTimeParser class : Removing next week.";
	private static final String LOGGER_MESSAGE_REMOVE_WEEKDAY = "DateAndTimeParser class : Removing weekday.";
	private static final String LOGGER_MESSAGE_REMOVE_NEXT_WEEKDAY = "DateAndTimeParser class : Removing next weekday.";
	private static final String LOGGER_MESSAGE_REMOVE_TIME = "DateAndTimeParser class : Removing time.";
	private static final String LOGGER_MESSAGE_REMOVE_HOLIDAY = "DateAndTimeParser class : Removing holiday.";
	private static final String LOGGER_MESSAGE_SET_DEFAULT_END_TIME = "DateAndTimeParser class : Setting default end time.";
	private static final String LOGGER_MESSAGE_SET_DEFAULT_START_TIME = "DateAndTimeParser class : Setting default start time.";
	private static final String LOGGER_MESSAGE_PROCESS_EXTRACT_DATE = "DateAndTimeParser class : Extracting date.";
	private static final String LOGGER_MESSAGE_PROCESS_CONVERT_DATE_ELEMENT = "DateAndTimeParser class : Converting date.";
	private static final String LOGGER_MESSAGE_CHECK_ABBREVIATIONS = "DateAndTimeParser class : Checking for abbreviations.";


	
	public DateTimeParser () {
		
		logger = LoggerFile.getLogger();
		
		sf = new SimpleDateFormat(DATE_FORMAT_WITH_TIME);
		sdf = new SimpleDateFormat(TIME_WITHOUT_DATE_FORMAT);
		df = new SimpleDateFormat(DATE_FORMAT_1);
		
		todayTypes = new ArrayList<>(Arrays.asList("tdy"));
		tomorrowTypes = new ArrayList<>(Arrays.asList("tmr", "tml", "tmrw", "2moro"));
		
		dayTypes = new ArrayList<>(Arrays.asList("mon", "monday", "tue", "tues", "tuesday", 
												 "wed", "wednesday", "thur", "thurs", "thursday", 
												 "fri", "friday", "sat", "saturday", "sun", "sunday"));
		
		monthTypes = new ArrayList<>(Arrays.asList("jan", "january", "feb", "february", "mar",
												   "march", "apr","april", "may","may", "june","june", 
												   "jul", "july", "aug", "august", "sept", "september", 
												   "oct", "october", "nov", "november", "dec", "december"));
		
		preposition = new ArrayList<>(Arrays.asList("on", "at", "by", "before", "in", "from" , "to"));
	
	}
	
	/*
	 * This method extracts the word "the day after tomorrow" and "day after
	 * "tomorrow" from the user input. 
	 * 
	 * @param userInput {@code String} 
	 * 
	 * @return {@code String} with "day after tomorrow" removed.  
	 * 
	 */
	protected String removeTheDayAfterTomorrow(String userInput) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_REMOVE_THE_DAY_AFTER_TOMORROW);
		
		List<Date> dates = new PrettyTimeParser().parse(userInput);
		
		if (userInput.contains(KEYWORD_THE_DAY_AFTER_TOMORROW) && dates.size() != 0) {
			userInput = userInput.replace(KEYWORD_THE_DAY_AFTER_TOMORROW, STRING_EMPTY);
			possibleDate = KEYWORD_THE_DAY_AFTER_TOMORROW.trim();
		}
		else if (userInput.contains(KEYWORD_DAY_AFTER_TOMORROW) && dates.size() != 0) {
			userInput = userInput.replace(KEYWORD_DAY_AFTER_TOMORROW, STRING_EMPTY);
			possibleDate = KEYWORD_THE_DAY_AFTER_TOMORROW.trim();
		}
		
		return userInput.trim();
	}
	
	/*
	 * This method extracts the word "tomorrow" 
	 * 
	 * @param userInput {@code String} 
	 * 
	 * @return {@code String} with "tomorrow" removed.  
	 * 
	 */
	protected String removeTomorrow(String userInput) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_REMOVE_TOMORROW);
		
		List<Date> dates = new PrettyTimeParser().parse(userInput);
		
		if ((userInput.contains(KEYWORD_TOMORROW_1) || userInput.contains(KEYWORD_TOMORROW_2))
			&& dates.size() != 0) {
			
			userInput = userInput.replace(KEYWORD_TOMORROW_1, STRING_EMPTY);
			setDateElements(KEYWORD_TOMORROW_1);
		}
		
		return userInput.trim();
	}
	
	/*
	 * This method extracts the word "yesterday" 
	 * 
	 * @param userInput {@code String} 
	 * 
	 * @return {@code String} with "yesterday" removed.  
	 * 
	 */
	protected String removeYesterday(String userInput) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_REMOVE_YESTERDAY);
		List<Date> dates = new PrettyTimeParser().parse(userInput);
		
		if (userInput.contains(KEYWORD_YESTERDAY) && dates.size() != 0) {
		
			userInput = userInput.replace(KEYWORD_YESTERDAY, STRING_EMPTY);
			possibleDate = KEYWORD_YESTERDAY;
		}
		
		return userInput.trim();
	}
	
	/*
	 * This method extracts the word "today" 
	 * 
	 * @param userInput {@code String} 
	 * 
	 * @return {@code String} with "today" removed.  
	 * 
	 */
	protected String removeToday(String userInput) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_REMOVE_TODAY);
		List<Date> dates = new PrettyTimeParser().parse(userInput);
		
		if (userInput.contains(KEYWORD_TODAY) && dates.size() != 0) {
		
			userInput = userInput.replace(KEYWORD_TODAY, STRING_EMPTY);
			possibleDate = KEYWORD_TODAY;
		}
		
		return userInput.trim();
	}
	
	/*
	 * This method extracts the word "this coming weekday" 
	 * 
	 * @param userInput {@code String} 
	 * 
	 * @return {@code String} with "this coming weekday" removed.  
	 * 
	 */
	protected String removeThisComingWeekday(String userInput) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_REMOVE_THIS_COMING_WEEKDAY);
		
		String[] str = userInput.split(STRING_SPLITTER);
		taskItems = new ArrayList<String>(Arrays.asList(str));
		
		if (userInput.toLowerCase().contains(KEYWORD_THIS_COMING)) {
			int index = taskItems.lastIndexOf(KEYWORD_COMING);
		
			taskItems.remove(index + 1);
			taskItems.remove(index);
			taskItems.remove(index - 1);
			
			userInput = toStringTaskElements(taskItems);
			possibleDate = taskItems.get(index - 1) + STRING_SPACING + taskItems.get(index) +
						   STRING_SPACING+ taskItems.get(index - 1);
		}
		
		return userInput.trim();
	}
	
	/*
	 * This method extracts the word "next few days" 
	 * 
	 * @param userInput {@code String} 
	 * 
	 * @return {@code String} with "next few days" removed.  
	 * 
	 */
	protected String removeNextFewDays(String userInput) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_REMOVE_NEXT_FEW_DAYS);
		
		String[] str = userInput.split(STRING_SPLITTER);
		taskItems = new ArrayList<String>(Arrays.asList(str));
		
		int indexOfNext = taskItems.lastIndexOf(KEYWORD_NEXT_1);
		int indexOfDays = taskItems.lastIndexOf(KEYWORD_DAYS);

		if (indexOfNext != 0 && (indexOfDays - indexOfNext) == 2  
			&& !userInput.contains(KEYWORD_NEXT_WEEK_2)) {
			
			logger.log(Level.WARNING, NULL_POINTER_EXCEPTION);
			
			possibleDate = taskItems.get(indexOfNext) + STRING_SPACING + taskItems.get(indexOfNext + 1) + 
						   STRING_SPACING + taskItems.get(indexOfDays);
			
			taskItems.remove(indexOfDays);
			taskItems.remove(indexOfNext + 1);
			taskItems.remove(indexOfNext);
			
			if (taskItems.get(indexOfNext - 1).contains(KEYWORD_THE)) {
				taskItems.remove(indexOfNext - 1);
			}
			userInput = toStringTaskElements(taskItems);
		}
		
		return userInput.trim();
	}
	
	/*
	 * This method extracts the numerical date (11/11, 11/11/16 etc)
	 * 
	 * @param userInput {@code String} 
	 * 
	 * @return {@code String} with numerical date removed.  
	 * 
	 */
	protected String removeNumericalDate(String userInput) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_REMOVE_NUMERICAL_DATE);
		
		String[] str = userInput.split(STRING_SPLITTER);
		taskItems = new ArrayList<String>(Arrays.asList(str));
		
		for (int i = 0; i < taskItems.size(); i++) {
		
			List<Date> dates = new PrettyTimeParser().parse(taskItems.get(i));
			
			if (dates.size() != 0) {
			
				String[] temp = taskItems.get(i).split(PUNCTUATION_REMOVER);
				
				if (temp.length >= 2) {
				
					possibleDate = taskItems.get(i);
					taskItems.remove(i);
				}
			}
		}
		
		userInput = toStringTaskElements(taskItems);
		return userInput;
		
	}
	
	/*
	 * This method extracts the words "next week" 
	 * 
	 * @param userInput {@code String} 
	 * 
	 * @return {@code String} with "next week" removed.  
	 * 
	 */
	
	protected String removeNextWeek(String userInput) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_REMOVE_NEXT_WEEK);
		
		if (userInput.contains(KEYWORD_NEXT_WEEK) || userInput.contains(KEYWORD_NEXT_WEEK_2) ) {
			userInput = userInput.replace(KEYWORD_NEXT_WEEK_2, STRING_EMPTY);
		}
		
		return userInput.trim();
	}
	
	/*
	 * This method extracts weekday from the user input.
	 * 
	 * @param userInput {@code String} 
	 * 
	 * @return {@code String} with weekday element removed.  
	 * 
	 */
	
	protected String removeWeekday(String userInput) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_REMOVE_WEEKDAY);
		
		List<Date> dates = new PrettyTimeParser().parse(userInput);
		String[] temp = userInput.split(STRING_SPLITTER);
		String newInput = "";
		
		if (dates.size() != 0) {
			for (int i = 0; i < temp.length; i++) {
				if (!dayTypes.contains(temp[i].toLowerCase())) {
					newInput += temp[i] + STRING_SPACING;
				}
			}
			userInput = newInput.trim();
		}
		
		return userInput;
	}
	
	/*
	 * This method extracts the next weekday elements (next thursday etc..) 
	 * 
	 * @param userInput {@code String} 
	 * 
	 * @return {@code String} with the next weekday element removed.  
	 * 
	 */
	protected String removeNextWeekday(String userInput) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_REMOVE_NEXT_WEEKDAY);
		
		String[] temp = userInput.split(STRING_SPLITTER);
		String newTaskName = "";
		int positionOfWeekday = 0;

		for (int i = 0; i < temp.length; i++) {
			
			if (temp[i].contains(KEYWORD_NEXT_1)) {
			
				positionOfWeekday = i + 1;
				List<Date> dates = new PrettyTimeParser().parse(temp[positionOfWeekday]);
				
				if (dates.size() != 0) {
				
					possibleDate += temp[i] + STRING_SPACING;
					temp[i] = STRING_EMPTY;
					
					possibleDate += temp[positionOfWeekday] + STRING_SPACING;
					temp[positionOfWeekday] = STRING_EMPTY;
					i++;
				}
			}
			newTaskName += temp[i] + STRING_SPACING;
		}
		
		return newTaskName.trim();
	}
	
	/*
	 * This method extracts the time element
	 * 
	 * @param userInput {@code String} 
	 * 
	 * @return {@code String} with the time element removed.  
	 * 
	 */
	protected String removeTime (String userInput) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_REMOVE_TIME);
		
		String[] str = userInput.split(STRING_SPLITTER);
		taskItems = new ArrayList<String>(Arrays.asList(str));
		
		for (int i = 0; i < taskItems.size(); i++) {
		
			List<Date> dates = new PrettyTimeParser().parse(taskItems.get(i));
	
			if ((taskItems.get(i).toLowerCase().contains(KEYWORD_AM) || taskItems.get(i).toLowerCase().contains(KEYWORD_PM) 
				|| taskItems.get(i).toLowerCase().contains(KEYWORD_HR) || taskItems.get(i).toLowerCase().contains(KEYWORD_HRS) ) 
				&& dates.size() != 0) {
			
				possibleDate += taskItems.get(i) + STRING_SPACING;
				taskItems.remove(i);
			}
		}
		
		userInput = toStringTaskElements(taskItems);
		return userInput;
	}
	
	/*
	 * This method extracts the holiday element 
	 * 
	 * @param userInput {@code String} 
	 * 
	 * @return {@code String} with the holiday element removed.  
	 * 
	 */
	private String removeHoliday(String userTask) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_REMOVE_HOLIDAY);
		
		String[] temp = userTask.split(STRING_SPLITTER);
		boolean containsPreposition = false;
		containsPreposition = containsPreposition(temp);
		
		if (userTask.toLowerCase().contains(STRING_HOLIDAY_VALENTINES_DAY) && containsPreposition == true) {
			userTask = userTask.toLowerCase().replace(STRING_HOLIDAY_VALENTINES_DAY, STRING_EMPTY);
			possibleDate = STRING_HOLIDAY_VALENTINES_DAY + STRING_SPACING;
		}
		else if (userTask.toLowerCase().contains(STRING_HOLIDAY_CHRISTMAS) && containsPreposition == true) {
			userTask = userTask.toLowerCase().replace(STRING_HOLIDAY_CHRISTMAS, STRING_EMPTY);
			possibleDate = STRING_HOLIDAY_CHRISTMAS + STRING_SPACING;
		}
		else if (userTask.toLowerCase().contains(STRING_HOLIDAY_NEW_YEAR) && containsPreposition == true) {
			userTask = userTask.toLowerCase().replace(STRING_HOLIDAY_NEW_YEAR, STRING_EMPTY);
			possibleDate = STRING_HOLIDAY_NEW_YEAR + STRING_SPACING;
		}
		else if (userTask.toLowerCase().contains(STRING_HOLIDAY_NEW_YEAR_EVE) && containsPreposition == true) {
			userTask = userTask.toLowerCase().replace(STRING_HOLIDAY_NEW_YEAR_EVE, STRING_EMPTY);
			possibleDate = STRING_HOLIDAY_NEW_YEAR_EVE + STRING_SPACING;
		}
		else if (userTask.toLowerCase().contains(STRING_HOLIDAY_HALLOWEEN) && containsPreposition == true) {
			userTask = userTask.toLowerCase().replace(STRING_HOLIDAY_HALLOWEEN, STRING_EMPTY);
			possibleDate = STRING_HOLIDAY_HALLOWEEN + STRING_SPACING;
		}
		else if (userTask.toLowerCase().contains(STRING_HOLIDAY_MOTHERS_DAY) && containsPreposition == true) {
			userTask = userTask.replace(STRING_HOLIDAY_MOTHERS_DAY, STRING_EMPTY);
			possibleDate = STRING_HOLIDAY_MOTHERS_DAY + STRING_SPACING;
		}
		else if (userTask.toLowerCase().contains(STRING_HOLIDAY_FATHERS_DAY) && containsPreposition == true) {
			userTask = userTask.toLowerCase().replace(STRING_HOLIDAY_FATHERS_DAY, STRING_EMPTY);
			possibleDate = STRING_HOLIDAY_FATHERS_DAY + STRING_SPACING;
		}
		
		return userTask;
	}

	/*
	 * This method extracts the english date element (1st May 2016 etc)
	 * 
	 * @param userInput {@code String} 
	 * 
	 * @return {@code String} with the english date element removed.  
	 * 
	 */
	protected String removeEnglishDate(String userInput) {

		List<Date> dates = new PrettyTimeParser().parse(userInput);
		String[] str = userInput.split(STRING_SPLITTER);
		taskItems = new ArrayList<String>(Arrays.asList(str));
		
		for (int i = 0; i < taskItems.size(); i++) {
			if (monthTypes.contains(taskItems.get(i).toLowerCase()) && dates.size() != 0) {
				taskItems.remove(i);
			}
		}

		return toStringTaskElements(taskItems);
	}

	/*
	 * This method checks if a string contains preposition
	 * 
	 * @param userInput {@code String[]} 
	 * 
	 * @return {@code boolean} 
	 * 
	 */
	protected boolean containsPreposition(String[] userInput) {
		
		for (int i = 0; i < userInput.length; i++) {
			if (preposition.contains(userInput[i])) {
				return true;
			}
		}
		
		return false;
	}
	
	/*
	 * This method converts short form of yesterday to proper word.
	 * 
	 * @param contentToAnalyse {@code ArrayList<String} 
	 * 
	 * @return {@code String} with short form of the word yesterday being
	 * replaced. 
	 * 
	 */
	protected String processYesterday (ArrayList<String> contentToAnalyse) {

		for (int i = 0; i < contentToAnalyse.size(); i++) {
			if ((contentToAnalyse.get(i).toLowerCase()).contains(KEYWORD_YESTERDAY_SHORTFORM)) {
				contentToAnalyse.set(i, KEYWORD_YESTERDAY);
			}
		}
		return toStringTaskElements(contentToAnalyse);
	}
	
	/*
	 * This method converts short form of today to proper word.
	 * 
	 * @param contentToAnalyse {@code ArrayList<String} 
	 * 
	 * @return {@code String} with short form of the word today being
	 * replaced. 
	 * 
	 */
	protected String processToday (ArrayList<String> contentToAnalyse) {

		for (int i = 0; i < contentToAnalyse.size(); i++) {
			if (todayTypes.contains(contentToAnalyse.get(i).toLowerCase())) {
				contentToAnalyse.set(i, KEYWORD_TODAY);
			}
		}
		return toStringTaskElements(contentToAnalyse);
	}
	
	/*
	 * This method converts short form of tomorrow to proper word.
	 * 
	 * @param contentToAnalyse {@code ArrayList<String} 
	 * 
	 * @return {@code String} with short form of the word tomorrow being
	 * replaced. 
	 * 
	 */
	protected String processTomorrow (ArrayList<String> contentToAnalyse) {
		
		for (int i = 0; i < contentToAnalyse.size(); i++) {
			if (tomorrowTypes.contains(contentToAnalyse.get(i).toLowerCase())) {
				contentToAnalyse.set(i, KEYWORD_TOMORROW_1);
			}
		}
		
		return toStringTaskElements(contentToAnalyse);
	}
	
	/*
	 * This method converts short form of "At" to proper word.
	 * 
	 * @param contentToAnalyse {@code ArrayList<String} 
	 * 
	 * @return {@code String} with short form of the word "At" being
	 * replaced. 
	 * 
	 */
	protected String processAt (ArrayList<String> contentToAnalyse) {

		for (int i = 0; i < contentToAnalyse.size(); i++) {
			if (contentToAnalyse.get(i).toLowerCase().contains(KEYWORD_AT_2)) {
				contentToAnalyse.set(i, KEYWORD_AT_1);
			}
		}
		
		return toStringTaskElements(contentToAnalyse);
	}
	
	/*
	 * This method converts numerical date dd/MM to dd/MM/yy
	 * 
	 * @param taskItems {@code ArrayList<String} 
	 * 
	 * @return {@code String} with numercial date converted to dd/MM/yy
	 * 
	 */
	protected String processNumericalDate(ArrayList<String> taskItems) {

		String[] str;
		
		for (int i = 0; i < taskItems.size(); i++) {
			List<Date> dates = new PrettyTimeParser().parse(taskItems.get(i));
			
			if (dates.size() != 0) {
				str = taskItems.get(i).split(PUNCTUATION_REMOVER);
			
				if (!taskItems.get(i).contains(KEYWORD_HASH_TAG) && !taskItems.get(i).toLowerCase().contains(KEYWORD_AM) 
					&& !taskItems.get(i).toLowerCase().contains(KEYWORD_PM)) {
					
					if (str.length == 2 && Integer.parseInt(str[0]) <= NUM_MAX_DAYS_PER_MONTH 
						&& Integer.parseInt(str[1]) <= NUM_MAX_MONTH_PER_YEAR) {
					
						int year = Calendar.getInstance().get(Calendar.YEAR);
						String newDate = str[0] + STRING_SLASH + str[1] + STRING_SLASH + year;
						taskItems.set(i, newDate);
					}
				}
			}
		}
		
		return toStringTaskElements(taskItems);
	}
	
	/*
	 * This method converts 2400HRS to 0000hrs on the following day.
	 * 
	 * @param taskItems {@code ArrayList<String} 
	 * 
	 * @return {@code String} 
	 * 
	 */
	protected String process2400hrs(ArrayList<String> taskItems) {
		
		for (int i = 0; i < taskItems.size(); i++) {
			if (taskItems.get(i).contains(DEFAULT_TIME_2400HRS)) {
				taskItems.set(i, DEFAULT_TIME_0000HRS);
			}
		}
		
		return toStringTaskElements(taskItems);
	}
	
	/*
	 * This method concatenates ArrayList<String> to String
	 * 
	 * @param taskNameArrayList {@code ArrayList<String} 
	 * 
	 * @return {@code String}
	 * 
	 */
	protected String toStringTaskElements(ArrayList<String> taskNameArrayList) {
		
		String name = "";
		
		for (int i = 0; i < taskNameArrayList.size(); i++) {
			name += taskNameArrayList.get(i) + STRING_SPACING; 
		}
		
		return name.trim();
	}
	
	/*
	 * This method checks and sets default end time.
	 * 
	 * @param date {@code Date} and currentTime {@code Date} 
	 * 
	 * @return {@code Date}
	 * 
	 */
	protected Date checkAndSetDefaultEndTime(Date date, Date currentTime) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_SET_DEFAULT_END_TIME);
		
		newDate = date;		
		String dateWithoutTime = df.format(date);
		String newDateWithTime= "";
		String timeAt6pm = dateWithoutTime + STRING_SPACING + DEFAULT_TIME_6PM;
		Calendar cal = Calendar.getInstance();
		
		try {
			
			Date dateWithoutDate = sdf.parse(sdf.format(date));
			Date currentWithoutDate = sdf.parse(sdf.format(currentTime));
			Date defaultDeadLineForExecutive = sf.parse(timeAt6pm);

			if (dateWithoutDate.equals(currentWithoutDate) && currentTime.before(defaultDeadLineForExecutive)) {
				
				newDate = defaultDeadLineForExecutive;
			} 
			else if (dateWithoutDate.equals(currentWithoutDate) && currentTime.after(defaultDeadLineForExecutive)) {
				
				newDateWithTime = dateWithoutTime + STRING_SPACING + DEFAULT_TIME_1159PM;
				newDate = sf.parse(newDateWithTime);
			}
			else if (date.before(currentTime)) {
				
				cal.setTime(date);
				cal.add(Calendar.DATE, 1);
				newDateWithTime = sf.format(cal.getTime()); 
				newDate = sf.parse(newDateWithTime);
			}
		}
		catch (ParseException e) {
			e.printStackTrace();
		}
		
		return newDate;
	}
	
	
	/*
	 * This method checks and sets default start time.
	 * 
	 * @param date {@code Date} and currentTime {@code Date} 
	 * 
	 * @return {@code Date}
	 * 
	 */
	
	protected Date checkAndSetDefaultStartTime(Date date, Date currentTime) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_SET_DEFAULT_START_TIME);
		
		newDate = date;		
		String dateWithoutTime = df.format(date);
		String currentDateWithoutTime= df.format(currentTime);
		String timeAt12am = dateWithoutTime + STRING_SPACING + DEFAULT_TIME_000000;
		
		try {
			Date dateWithoutDate = sdf.parse(sdf.format(date));
			Date currentWithoutDate = sdf.parse(sdf.format(currentTime));
			Date defaultStartTime = sf.parse(timeAt12am);
			
			if (dateWithoutDate.equals(currentWithoutDate) && dateWithoutTime.equals(currentDateWithoutTime)) {
				newDate = currentTime;
			} 
			else if (!dateWithoutTime.equals(currentDateWithoutTime) && dateWithoutDate.equals(currentWithoutDate)) {
				newDate = defaultStartTime;
			}
			else {
				newDate = date;
				
			}
		}
		catch (ParseException e) {
			e.printStackTrace();
		}
		
		return newDate;
	}
	
	/*
	 * This method checks if a string has date and time elements.
	 * 
	 * @param userTask {@code String} 
	 * 
	 * @return {@code boolean} true if consists date and time elements.
	 * 
	 */
	protected boolean hasDateAndTimeElements(String userTask) {
		
		String temp = "";
		temp = extractDate(userTask);
		
		return (temp.trim().equals(userTask.trim())) ? false : true;
	}
	
	/*
	 * This method extracts date and time element from a string
	 * 
	 * @param userTask {@code String}
	 * 
	 * @return {@code String} with date and time elements removed.
	 * 
	 */
	protected String extractDate(String userTask) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_EXTRACT_DATE);
		
		String temp = "";
		
		temp = removeHoliday(userTask);
		temp = removeTheDayAfterTomorrow(temp);
		temp = removeYesterday(temp);
		temp = removeTomorrow(temp);
		temp = removeToday(temp);
		temp = removeThisComingWeekday(temp);
		temp = removeNextFewDays(temp);
		temp = removeNextWeek(temp);
		temp = removeWeekday(temp);
		temp = removeNextWeekday(temp);
		temp = removeTime(temp);
		temp = removeNumericalDate(temp);
		temp = removeEnglishDate(temp);
		
		return temp;
	}
	
	/*
	 * This method checks for date and time element of an event task.
	 * 
	 * @param taskName {@code String}, LAST_POSITION_OF_FROM {@code int} and
	 * LAST_POSITION_OF_TO {@code int} 
	 * 
	 * @return {@code boolean}
	 * 
	 */
	protected boolean checkForDateAndTime(String taskName, int LAST_POSITION_OF_FROM, int LAST_POSITION_OF_TO) {	
		
		String str = taskName.substring(LAST_POSITION_OF_FROM, taskName.length());
		List<Date> dates = new PrettyTimeParser().parse(str);
		
		return (dates.size() != 0) ? true : false; 
	}
	
	/*
	 * This method converts dd/MM/yyyy to MM/dd/yyyy format for PrettyTime parsing.
	 * 
	 * @param taskItems {@code ArrayList<String>}
	 * 
	 * @return {@code String}
	 * 
	 */
	protected String checkAndConvertDateElement(ArrayList<String> taskItems) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_CONVERT_DATE_ELEMENT);
		
		DateFormat destDf = new SimpleDateFormat(DATE_FORMAT_2);
	
		for (int i = 0; i < taskItems.size(); i++) {
			
			try {
				DateFormat srcDf = new SimpleDateFormat(DATE_FORMAT_1);
				Date date = srcDf.parse(taskItems.get(i));
				taskItems.set(i, destDf.format(date));
			}
			catch (ParseException e) {		
				e.printStackTrace();
			}
			
			try {
				DateFormat srcDf = new SimpleDateFormat(DATE_FORMAT_3);
				Date date = srcDf.parse(taskItems.get(i));
				taskItems.set(i, destDf.format(date));
			}
			catch (ParseException e) {		
				e.printStackTrace();
			}
			
			try {
				DateFormat srcDf = new SimpleDateFormat(DATE_FORMAT_4);
				Date date = srcDf.parse(taskItems.get(i));
				taskItems.set(i, destDf.format(date));
			}
			catch (ParseException e) {		
				e.printStackTrace();
			}
		}
		
		return toStringTaskElements(taskItems);
	}
	
	/*
	 * This method checks and processes abbreviations of
	 * 
	 * @param taskName {@code String}, LAST_POSITION_OF_FROM {@code int} and
	 * LAST_POSITION_OF_TO {@code int} 
	 * 
	 * @return {@code boolean}
	 * 
	 */
	protected String checkForAbbreviation(ArrayList<String> taskItems) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_CHECK_ABBREVIATIONS);
		
		String name = "";
		name = processToday(taskItems);
		name = processTomorrow(taskItems);
		name = processYesterday(taskItems);
		name = processAt(taskItems);
		name = process2400hrs(taskItems);
		name = processNumericalDate(taskItems);
		
		return name;
	}
	

	protected String getConfirmTaskName() {
		return this.confirmTaskName;
	}
	
	private void setDateElements(String possibleDate) {
		this.possibleDate = possibleDate;
	}
	
	protected String getDateElements() {
		return this.possibleDate;
	}
}
```
###### /src/Parser/DeleteParser.java
``` java
package Parser;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import Command.*;
import Logger.*;

public class DeleteParser {
	
	private static Logger logger;
	private DELETE_TYPE deleteType;
	private ArrayList<String> tagToDelete; 
	private ArrayList<Integer> indexToDelete;
	
	// Constants
	private static final String STRING_CHECKER_ALL = "all";
	private static final String STRING_CHECKER_TO = "to";
	private static final String STRING_CHECKER_HYPHEN = "-";
	private static final String STRING_HASH_TAG = "#";
	private static final String STRING_CHECKER_TAG = "tag";
	private static final String STRING_CHECKER_CATEGORY = "category";
	private static final String STRING_START_DATE = "start date";
	private static final String STRING_END_DATE = "end date";
	private static final String STRING_START_INDICATOR = "start";
	private static final String STRING_END_INDICATOR = "end";
	private static final String STRING_SPLITTER = "\\s+";
	private static final String STRING_EMPTY = "";
	private static final String PUNCTUATION_REMOVER = "[:.,]";
	private static final int FIRST_ELEMENT = 0;
	private static final int SECOND_ELEMENT = 2;
	private static final int NUM_ELEMENTS_IN_RANGE = 3;
	
	// Logging messages for methods and processes.
	private static final String LOGGER_MESSAGE_EXECUTE_DELETE_PARSER = "Delete Parser: Processing executeDeleteParser method.";
	private static final String LOGGER_MESSAGE_EXIT_DELETE_PARSER = "Delete Parser: Exiting executeDeleteParser method.";
	private static final String LOGGER_MESSAGE_PROCESS_DELETE_TYPE = "Delete Parser: Analysing delete type.";
	private static final String LOGGER_MESSAGE_DETERMINE_DELETE_TYPE = "Delete Parser: Processing delete type.";
	private static final String LOGGER_MESSAGE_IS_TASK_INDEX = "Delete Parser: Analysing if deleting tags, date or indexes.";
	private static final String LOGGER_MESSAGE_DELETE_ALL_INDEXES = "Delete Parser: Delete type is all indexes .";
	private static final String LOGGER_MESSAGE_DELETE_ALL_TAGS = "Delete Parser: Delete type is all tags .";
	private static final String LOGGER_MESSAGE_DELETE_SINGLE_INDEX = "Delete Parser: Delete type is singe index.";
	private static final String LOGGER_MESSAGE_DELETE_SINGLE_TAG = "Delete Parser: Delete type is single tag.";
	private static final String LOGGER_MESSAGE_DELETE_RANGE_INDEXES = "Delete Parser: Delete type is range indexes .";
	private static final String LOGGER_MESSAGE_DELETE_MULTIPLE_INDEXES = "Delete Parser: Delete type is multiple indexes .";
	private static final String LOGGER_MESSAGE_DELETE_MULTIPLE_TAGS = "Delete Parser: Delete type is multiple tags .";
	private static final String LOGGER_MESSAGE_DELETE_START_DATE = "Delete Parser: Delete type is start date .";
	private static final String LOGGER_MESSAGE_DELETE_END_DATE = "Delete Parser: Delete type is end date .";
	private static final String LOGGER_MESSAGE_DELETE_IS_INVALID = "Delete Parser: Delete type is invalid .";
	
	public DeleteParser() {
		this.tagToDelete = new ArrayList<String>();
		this.indexToDelete = new ArrayList<Integer>();
		logger = LoggerFile.getLogger();
	}

	/*
	 * This method executes the parsing of deletion.
	 * 
	 * @param commandUtil {@code CommandUtils} and userTask {@code String}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	
	protected CommandUtils executeDeleteParser(CommandUtils commandUtil, String userTask) {
		
		assert (userTask != null);
		logger.log(Level.INFO, LOGGER_MESSAGE_EXECUTE_DELETE_PARSER);
		
		boolean isInteger = false;
		String[] str = userTask.replaceAll(PUNCTUATION_REMOVER, STRING_EMPTY).split(STRING_SPLITTER);
		isInteger = isTaskIndex(str);
		commandUtil = detemineDeleteType(commandUtil, userTask.toLowerCase(), isInteger);
		deleteType = commandUtil.getDeleteType();
		
		logger.log(Level.INFO, LOGGER_MESSAGE_EXIT_DELETE_PARSER);
		return processDeleteType(commandUtil, str);
	}

	/*
	 * This method process the input based on deletion type.
	 * 
	 * @param commandUtil {@code CommandUtils} and userTask {@code String[]}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	
	private CommandUtils processDeleteType(CommandUtils commandUtil, String[] str) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_DELETE_TYPE);
		
		switch (deleteType) {
		
			case SINGLE_INDEX:
				return parseSingleDeleteIndex(commandUtil,str);
			case SINGLE_TAG:
				return parseSingleDeleteTag(commandUtil,str);
			case MULTIPLE_INDEXES:
				return parseMultipleDeleteIndexes(commandUtil,str);
			case MULTIPLE_TAGS:
				return parseMutipleDeleteTags(commandUtil,str);
			case RANGE_INDEXES:
				return parseRangeDelete(commandUtil, str);
			case ALL_INDEXES:
				break;
			case ALL_TAGS:
				break;
			case START_DATE:
				return parseDeleteStartDate(commandUtil, str);
			case END_DATE:
				return parseDeleteEndDate(commandUtil, str);
			default:
				break;
		}
		return commandUtil;
	}
	

	/*
	 * This method determines the type of deletion.
	 * 
	 * @param commandUtil {@code CommandUtils}, userTask {@code String}
	 * 		  and isInteger {@code boolean}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	private CommandUtils detemineDeleteType(CommandUtils commandUtil, String userTask, boolean isInteger) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_DETERMINE_DELETE_TYPE);
		
		if (checkIfDeleteAll(userTask)) {
			logger.log(Level.INFO, LOGGER_MESSAGE_DELETE_ALL_INDEXES);
			commandUtil.setDeleteType(DELETE_TYPE.ALL_INDEXES);
		}
		else if (checkIfDeleteAllTag(userTask)) {
			logger.log(Level.INFO, LOGGER_MESSAGE_DELETE_ALL_TAGS);
			commandUtil.setDeleteType(DELETE_TYPE.ALL_TAGS);
		}
		else if (checkIfDeleteSingleIndex(userTask) && isInteger == true){
			logger.log(Level.INFO, LOGGER_MESSAGE_DELETE_SINGLE_INDEX);
			commandUtil.setDeleteType(DELETE_TYPE.SINGLE_INDEX);
		}
		else if (checkIfDeleteSingleTag(userTask) && isInteger == false) {
			logger.log(Level.INFO, LOGGER_MESSAGE_DELETE_SINGLE_TAG);
			commandUtil.setDeleteType(DELETE_TYPE.SINGLE_TAG);	
		}
		else if (checkIfDeleteRange(userTask) && isInteger == true) {
			logger.log(Level.INFO, LOGGER_MESSAGE_DELETE_RANGE_INDEXES);
			commandUtil.setDeleteType(DELETE_TYPE.RANGE_INDEXES);
		}
		else if (checkIfDeleteMultiple(userTask) && isInteger == true) {
			logger.log(Level.INFO, LOGGER_MESSAGE_DELETE_MULTIPLE_INDEXES);
			commandUtil.setDeleteType(DELETE_TYPE.MULTIPLE_INDEXES);
		}
		else if (checkIfDeleteMultiple(userTask) && isInteger == false) {
			logger.log(Level.INFO, LOGGER_MESSAGE_DELETE_MULTIPLE_TAGS);
			commandUtil.setDeleteType(DELETE_TYPE.MULTIPLE_TAGS);
		}
		else if(checkIfDeleteStartDate(userTask)) {
			logger.log(Level.INFO, LOGGER_MESSAGE_DELETE_START_DATE);
			commandUtil.setDeleteType(DELETE_TYPE.START_DATE);
		}
		else if(checkIfDeleteEndDate(userTask)) {
			logger.log(Level.INFO, LOGGER_MESSAGE_DELETE_END_DATE);
			commandUtil.setDeleteType(DELETE_TYPE.END_DATE);
		}
		else {
			logger.log(Level.INFO, LOGGER_MESSAGE_DELETE_IS_INVALID);
			commandUtil.setDeleteType(DELETE_TYPE.INVALID);
		}
		return commandUtil;
	}

	/*
	 * This method checks if it is deleting tag(s) or index(es)
	 * 
	 * @param str {@code String[]}
	 * 
	 * @return {@code boolean}
	 * 			
	 * 
	 */
	private boolean isTaskIndex(String[] str) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_IS_TASK_INDEX);
		return (str[FIRST_ELEMENT].startsWith(STRING_HASH_TAG)) ? false : true;
	}

	/*
	 * This method checks if it is deleting tag(s) or index(es)
	 * 
	 * @param commandUtil {@code CommandUtils} and str {@code String[]}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	private CommandUtils parseDeleteEndDate(CommandUtils commandUtil, String[] str) {
		
		if (!str[FIRST_ELEMENT].contains(STRING_END_INDICATOR)) {
			indexToDelete.add(Integer.parseInt(str[0]));
			commandUtil.setIndexToDelete(indexToDelete);
		}
		else {
			commandUtil.setDeleteType(DELETE_TYPE.INVALID);
		}
		return commandUtil;
	}

	/*
	 * This method processes the deletion of start date
	 * 
	 * @param commandUtil {@code CommandUtils} and str {@code String[]}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	
	private CommandUtils parseDeleteStartDate(CommandUtils commandUtil, String[] str) {
		
		if (!str[FIRST_ELEMENT].contains(STRING_START_INDICATOR)) {
			indexToDelete.add(Integer.parseInt(str[FIRST_ELEMENT]));
			commandUtil.setIndexToDelete(indexToDelete);
		}
		else {
			commandUtil.setDeleteType(DELETE_TYPE.INVALID);
		}
		return commandUtil;
	}

	/*
	 * This method processes the deletion of a range of indexes
	 * 
	 * @param commandUtil {@code CommandUtils} and str {@code String[]}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	
	private CommandUtils parseRangeDelete(CommandUtils commandUtil, String[] str) {
		// Example: delete 1 to 5 / delete 1 - 5
		if (str.length == NUM_ELEMENTS_IN_RANGE) {
			for (int i = Integer.parseInt(str[FIRST_ELEMENT]); i < Integer.parseInt(str[SECOND_ELEMENT]) + 1; i++) {
				indexToDelete.add(i);
			}
		}
		commandUtil.setIndexToDelete(indexToDelete);
		return commandUtil;
	}

	/*
	 * This method processes the deletion of multiple indexes
	 * 
	 * @param commandUtil {@code CommandUtils} and str {@code String[]}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	
	private CommandUtils parseMultipleDeleteIndexes(CommandUtils commandUtil, String[] str) {
		// Example: delete 1 4 9 14
		for (int i = 0; i < str.length; i++) {
			indexToDelete.add(Integer.parseInt(str[i]));
		}
		commandUtil.setIndexToDelete(indexToDelete);
		return commandUtil;
	}
	
	/*
	 * This method processes the deletion of multiple tags.
	 * 
	 * @param commandUtil {@code CommandUtils} and str {@code String[]}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	
	private CommandUtils parseMutipleDeleteTags(CommandUtils commandUtil, String[] str) {
		// Example: delete #nus #soc #singapore
		for (int i = 0; i < str.length; i++) {
			if (!str[i].contains(STRING_CHECKER_HYPHEN)) {
				tagToDelete.add(str[i].substring(1, str[i].length()));
			}
		}
		commandUtil.setTagToDelete(tagToDelete);
		return commandUtil;
	}

	/*
	 * This method processes deletion of a single tag
	 * 
	 * @param commandUtil {@code CommandUtils} and str {@code String[]}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	
	private CommandUtils parseSingleDeleteTag(CommandUtils commandUtil, String[] str) {
		// Example: delete #nus
		if (!str[FIRST_ELEMENT].contains(STRING_CHECKER_HYPHEN)) {
			tagToDelete.add(str[FIRST_ELEMENT].substring(1, str[FIRST_ELEMENT].length()));
			commandUtil.setTagToDelete(tagToDelete);
		}
		return commandUtil;
	}
	
	/*
	 * This method processes deletion of a single index
	 * 
	 * @param commandUtil {@code CommandUtils} and str {@code String[]}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	private CommandUtils parseSingleDeleteIndex(CommandUtils commandUtil, String[] str) {
		indexToDelete.add(Integer.parseInt(str[FIRST_ELEMENT]));
		commandUtil.setIndexToDelete(indexToDelete);
		return commandUtil;
	}

	/*
	 * This method checks if it is deleting an end date of a task.
	 * 
	 * @param userTask {@code String}
	 * 
	 * @return {@code boolean}
	 * 			
	 * 
	 */
	
	private boolean checkIfDeleteEndDate(String userTask) {
		return (userTask.contains(STRING_END_DATE)) ? true : false;
	}
	
	/*
	 * This method checks if it is deleting a start date of a task.
	 * 
	 * @param userTask {@code String}
	 * 
	 * @return {@code boolean}
	 * 			
	 * 
	 */
	
	private boolean checkIfDeleteStartDate(String userTask) {
		return (userTask.contains(STRING_START_DATE)) ? true : false;
	}

	/*
	 * This method checks if it is deleting all tags
	 * 
	 * @param userTask {@code String}
	 * 
	 * @return {@code boolean}
	 * 			
	 * 
	 */
	
	private boolean checkIfDeleteAllTag(String userTask) {
		return (userTask.contains(STRING_CHECKER_ALL) && (userTask.contains(STRING_CHECKER_TAG) 
				|| userTask.contains(STRING_CHECKER_CATEGORY))) ? true : false;
	}


	/*
	 * This method checks if it is deleting all indexes
	 * 
	 * @param userTask {@code String}
	 * 
	 * @return {@code boolean}
	 * 			
	 * 
	 */
	private boolean checkIfDeleteAll(String userTask) {
		return (userTask.contains(STRING_CHECKER_ALL) && !(userTask.contains(STRING_CHECKER_TAG) 
				|| userTask.contains(STRING_CHECKER_CATEGORY))) ? true : false;
	}


	/*
	 * This method checks if it is deleting a range of indexes or tags
	 * 
	 * @param userTask {@code String}
	 * 
	 * @return {@code boolean}
	 * 			
	 * 
	 */
	private boolean checkIfDeleteRange(String userTask) {
		return ((userTask.contains(STRING_CHECKER_HYPHEN) && !userTask.contains(STRING_HASH_TAG))
				|| (userTask.contains(STRING_CHECKER_TO))) 
				? true : false;
	}


	/*
	 * This method checks if it is deleting multiple tags or indexes
	 * 
	 * @param userTask {@code String}
	 * 
	 * @return {@code boolean}
	 * 			
	 * 
	 */
	
	private boolean checkIfDeleteMultiple(String userTask) {
		
		String[] str = userTask.toLowerCase().split(STRING_SPLITTER);	
		
		return (str.length > 1 && !checkIfDeleteRange(userTask) && 
				!checkIfDeleteEndDate(userTask) &&
				!checkIfDeleteStartDate(userTask)) ? true : false;
	
	}
	

	/*
	 * This method checks if it is deleting single indexes
	 * 
	 * @param userTask {@code String}
	 * 
	 * @return {@code boolean}
	 * 			
	 * 
	 */

	private boolean checkIfDeleteSingleIndex(String userTask) {
		
		String[] str = userTask.toLowerCase().split(STRING_SPLITTER);	
		
		return (str.length == 1 && !userTask.contains(STRING_CHECKER_ALL)) ? true : false;
	
	}
	

	/*
	 * This method checks if it is deleting single tag.
	 * 
	 * @param userTask {@code String}
	 * 
	 * @return {@code boolean}
	 * 			
	 * 
	 */
	private boolean checkIfDeleteSingleTag(String userTask) {
		
		String[] temp = userTask.split(STRING_SPLITTER);
		
		return (temp.length == 1 && temp[FIRST_ELEMENT].startsWith(STRING_HASH_TAG) 
				&& !temp[FIRST_ELEMENT].contains(STRING_CHECKER_HYPHEN)) ? true : false;
	
	}

}

```
###### /src/Parser/EditParser.java
``` java
package Parser;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.ocpsoft.prettytime.nlp.PrettyTimeParser;

import Command.*;
import Logger.LoggerFile;
import Task.*;

public class EditParser {
	
	private static Logger logger;
	
	// Constants
	private static final String KEYWORD_TO = " to ";
	private static final String KEYWORD_FROM = " from ";
	private static final String KEYWORD_AT = " at ";
	private static final String KEYWORD_BEFORE = " before ";
	private static final String KEYWORD_ON = " on ";
	private static final String KEYWORD_BY = " by ";
	private static final String STRING_HASH_TAG = "#";
	private static final String PUNCTUATION_REMOVER = "[:-]";
	private static final String STRING_SPLITTER = "\\s+";
	private static final String STRING_EMPTY = "";
	private static final String STRING_SPACING = " ";
	private static final int NUM_NO_DATE_ELEMENT = 0;
	private static final int NUM_FIRST_ELEMENT = 0;

	// Logging messages for processing methods.
	private static final String LOGGER_MESSAGE_PROCESS_EDIT_PARSER = "EditParser class: Entering EditParser class.";
	private static final String LOGGER_MESSAGE_EXIT_EDIT_PARSER = "EditParser class: Exiting EditParser class.";
	private static final String LOGGER_MESSAGE_PROCESS_EDIT_TYPE = "EditParser class: Analysing edit type.";
	private static final String LOGGER_MESSAGE_PROCESS_TASK_NAME_TYPE = "EditParser class: Processing edit task name type.";
	private static final String LOGGER_MESSAGE_PROCESS_EVENT_TIME = "EditParser class: Processing edit event type.";
	private static final String LOGGER_MESSAGE_PROCESS_START_TIME = "EditParser class: Processing edit start time.";
	private static final String LOGGER_MESSAGE_PROCESS_DEADLINED = "EditParser class: Processing edit deadline.";
	private static final String LOGGER_MESSAGE_PROCESS_END_TIME = "EditParser class: Processing edit end time.";
	private static final String LOGGER_MESSAGE_PROCESS_TAG_TYPE = "EditParser class: Processing edit tag type.";
	private static final String LOGGER_MESSAGE_PROCESS_INVALID = "EditParser class: Invalid edit type.";
	private static final String LOGGER_MESSAGE_INDEX_OUT_OF_BOUND = "WARNING! Method may throw index out of bound.";
	private static final String LOGGER_MESSAGE_PROCESS_EDIT_TAG_METHOD = "EditParser class: Processing editTag method.";
	private static final String LOGGER_MESSAGE_PROCESS_EXTRACT_TASK_ID = "EditParser class: Extracting task id.";
	
	private String newTaskName = "";
	private int INDEX_OF_LAST_TO = -1;
	private int INDEX_OF_LAST_FROM = -1;
	
	private EDIT_TYPE editType;
	private ArrayList<String> editTaskElements;
	private ArrayList<String> newTag;
	
	private Date date;
	private DateTimeParser dt;
	private AddParser ap;
	
	public EditParser() {
		
		newTag = new ArrayList<String>();
		dt = new DateTimeParser();
		date = new Date();
		logger = LoggerFile.getLogger();
		ap = new AddParser();
	
	}
	
	/*
	 * This method process the edit command.
	 * 
	 * @param commandUtil {@code CommandUtils} and userInput {@code String}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	
	protected CommandUtils executeEditParser(CommandUtils commandUtil, String userInput) {
		
		assert (userInput != null);
		logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_EDIT_PARSER);
		
		String[] editElements = userInput.replaceAll(PUNCTUATION_REMOVER, STRING_EMPTY).split(STRING_SPLITTER);
		editTaskElements = new ArrayList<String>(Arrays.asList(editElements));
		newTaskName = dt.checkForAbbreviation(editTaskElements);
		
		String[] updatedElements = newTaskName.replaceAll(PUNCTUATION_REMOVER, STRING_EMPTY).split(STRING_SPLITTER);
		editTaskElements = new ArrayList<String>(Arrays.asList(updatedElements));
		
		userInput = extractTaskID(commandUtil, editTaskElements);
		commandUtil = ap.executeAddParser(commandUtil, userInput);
		commandUtil = determineEditType(commandUtil, userInput);
		editType = commandUtil.getEditType();
		
		logger.log(Level.INFO, LOGGER_MESSAGE_EXIT_EDIT_PARSER);
		return processEditType(commandUtil, userInput);
	}

	/*
	 * This method process the edit type".
	 * 
	 * @param commandUtil {@code CommandUtils} and userInput {@code String}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	private CommandUtils processEditType(CommandUtils commandUtil, String userInput) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_EDIT_TYPE);
		
		switch(editType) {
		
		case TASK_NAME:
			logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_TASK_NAME_TYPE);
			return parseEditTaskName(commandUtil, userInput);
			
		case EVENT_TIME:
			logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_EVENT_TIME);
			return parseEditEventTime(commandUtil, userInput);
			
		case START_TIME:
			logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_START_TIME);
			return parseEditStartTime(commandUtil, userInput);
			
		case DEADLINED:
			logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_DEADLINED);
			return parseEditDeadLined(commandUtil, userInput);
			
		case END_TIME:
			logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_END_TIME);
			return parseEditEndTime(commandUtil, userInput);
			
		case TAG:
			logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_TAG_TYPE);
			return parserEditTag(commandUtil, userInput);
			
		case INVALID:
			logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_INVALID);
			break;
		}
		return commandUtil;
	}
	
	/*
	 * This method process the edit of tag.
	 * 
	 * @param commandUtil {@code CommandUtils} and userInput {@code String}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	private CommandUtils parserEditTag(CommandUtils commandUtil, String userInput) {
		
		String[] str = userInput.trim().split(STRING_SPLITTER);
		assert (str.length <= 3 && str.length > 0);
		
		System.out.println("parseEditTag : " + userInput);
		logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_EDIT_TAG_METHOD);
		logger.log(Level.WARNING, LOGGER_MESSAGE_INDEX_OUT_OF_BOUND);
		
		if (str[NUM_FIRST_ELEMENT].startsWith(STRING_HASH_TAG) && str[2].startsWith(STRING_HASH_TAG)) {
			
			commandUtil.setOldTag(str[NUM_FIRST_ELEMENT].substring(1, str[NUM_FIRST_ELEMENT].length()));
			newTag.add(str[2].substring(1, str[2].length()));
			commandUtil.setTaskTag(newTag);	
		}
		else {
			commandUtil.setEditType(EDIT_TYPE.INVALID);
		}
		return commandUtil;
	}

	/*
	 * This method process the edit of end time.
	 * 
	 * @param commandUtil {@code CommandUtils} and userInput {@code String}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	private CommandUtils parseEditEndTime(CommandUtils commandUtil, String userInput) {
		
		INDEX_OF_LAST_TO = userInput.lastIndexOf(KEYWORD_TO);
		String temp = userInput.substring(INDEX_OF_LAST_TO, userInput.length());
		
		commandUtil.setTaskName(userInput.substring(0, userInput.lastIndexOf(KEYWORD_TO)));
		List<Date> dates = new PrettyTimeParser().parse(temp);
		commandUtil.setEndTime(dt.checkAndSetDefaultEndTime(dates.get(NUM_FIRST_ELEMENT), date));
		
		return commandUtil;
	}

	/*
	 * This method process the edit of start time.
	 * 
	 * @param commandUtil {@code CommandUtils} and userInput {@code String}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	
	private CommandUtils parseEditStartTime(CommandUtils commandUtil, String userInput) {
		
		INDEX_OF_LAST_FROM = userInput.lastIndexOf(KEYWORD_FROM);
		String temp = userInput.substring(INDEX_OF_LAST_FROM, userInput.length());
		
		commandUtil.setTaskName(userInput.substring(0, userInput.lastIndexOf(KEYWORD_FROM)));
		List<Date> dates = new PrettyTimeParser().parse(temp);
		commandUtil.setStartTime(dates.get(NUM_FIRST_ELEMENT));
		
		return commandUtil;
	}

	/*
	 * This method process the edit of deadline.
	 * 
	 * @param commandUtil {@code CommandUtils} and userInput {@code String}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	private CommandUtils parseEditDeadLined(CommandUtils commandUtil, String userInput) {
		AddParser ap = new AddParser();
		commandUtil = ap.executeAddParser(commandUtil, userInput);
		return commandUtil;
	}

	/*
	 * This method process the edit of event time.
	 * 
	 * @param commandUtil {@code CommandUtils} and userInput {@code String}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	private CommandUtils parseEditEventTime(CommandUtils commandUtil, String userInput) {
		AddParser ap = new AddParser();
		return ap.executeAddParser(commandUtil, userInput);
	}
	
	/*
	 * This method process the edit of task name".
	 * 
	 * @param commandUtil {@code CommandUtils} and userInput {@code String}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	private CommandUtils parseEditTaskName(CommandUtils commandUtil, String userInput) {
		AddParser ap = new AddParser();
		return ap.executeAddParser(commandUtil, userInput);
	}

	/*
	 * This method determines the type of edit.
	 * 
	 * @param commandUtil {@code CommandUtils} and userInput {@code String}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	private CommandUtils determineEditType(CommandUtils commandUtil, String userInput) {
		
		if (commandUtil.getType() == TASK_TYPE.FLOATING && !userInput.trim().startsWith(STRING_HASH_TAG)) {
			commandUtil.setEditType(EDIT_TYPE.TASK_NAME);
		}
		/*
		 * @Description: edits the deadline of task 
		 * Example: edit 1 by tomorrow
		 */
		else if (commandUtil.getType() == TASK_TYPE.DEADLINED && !hasEndTime(userInput) && !hasStartTime(userInput)
				&& !userInput.trim().startsWith(STRING_HASH_TAG)) {
			commandUtil.setEditType(EDIT_TYPE.DEADLINED);
		}
		/*
		 * @ Description: edits the end time of an event
		 *  Example: edit 1 to 24.07.2016
		 */
		else if (!hasDeadLined(userInput) && hasEndTime(userInput) && !hasStartTime(userInput)
				&& !userInput.trim().startsWith(STRING_HASH_TAG)) {
			commandUtil.setEditType(EDIT_TYPE.END_TIME);
		}
		/*
		 * @ Description: edits the start time of an event
		 *  Example: edit 1 from 24.07.2016
		 */
		else if (!hasDeadLined(userInput) && !hasEndTime(userInput) && hasStartTime(userInput)
				&& !userInput.trim().startsWith(STRING_HASH_TAG)) {
			commandUtil.setEditType(EDIT_TYPE.START_TIME);
		}
		/*
		 * @ Description: edits the start and end time of an event
		 *  Example: edit 1 from 24.07.2016 to 28.07.2016
		 */
		else if (commandUtil.getType() == TASK_TYPE.EVENT && !userInput.trim().startsWith(STRING_HASH_TAG)) {
			commandUtil.setEditType(EDIT_TYPE.EVENT_TIME);
		}
		/*
		 * @ Description: edits a tag to a new name
		 *  Example: edit 1 #soc to #nus
		 */
		else if (userInput.trim().startsWith(STRING_HASH_TAG)) {
			commandUtil.setEditType(EDIT_TYPE.TAG);
		}
		else if (commandUtil.getType() == TASK_TYPE.DEADLINED && !hasDeadLined(userInput) && hasEndTime(userInput) 
				&& !hasStartTime(userInput) && !userInput.trim().startsWith(STRING_HASH_TAG)) {
			commandUtil.setEditType(EDIT_TYPE.DEADLINED);
		}
		else {
			commandUtil.setEditType(EDIT_TYPE.INVALID);
		} 
		return commandUtil;
	}

	/*
	 * This method checks if input contains deadline.
	 * 
	 * @param userInput {@code String}
	 * 
	 * @return {@code boolean}
	 * 			
	 * 
	 */
	private boolean hasDeadLined(String userInput) {
		
		List<Date> dates = new PrettyTimeParser().parse(userInput);
		
		if (userInput.contains(KEYWORD_BEFORE) || userInput.contains(KEYWORD_BY) 
			|| userInput.contains(KEYWORD_ON) || userInput.contains(KEYWORD_AT)) {
			
			return (dates.size() != NUM_NO_DATE_ELEMENT) ? true : false;
		
		}
		else {
			return false;
		}
	}
	
	/*
	 * This method checks if input contains "start time".
	 * 
	 * @param userInput {@code String}
	 * 
	 * @return {@code boolean}
	 * 			
	 * 
	 */
	private boolean hasStartTime(String userInput) {
	
		List<Date> dates = new PrettyTimeParser().parse(userInput);
		
		return (userInput.contains(KEYWORD_FROM) && dates.size() != NUM_NO_DATE_ELEMENT) ? true : false;
	}

	/*
	 * This method checks if input contains "end time".
	 * 
	 * @param userInput {@code String}
	 * 
	 * @return {@code boolean}
	 * 			
	 * 
	 */
	private boolean hasEndTime(String userInput) {
		
		List<Date> dates = new PrettyTimeParser().parse(userInput);
		
		return (userInput.contains(KEYWORD_TO) && dates.size() != NUM_NO_DATE_ELEMENT
				&& !userInput.contains(STRING_HASH_TAG)) ? true : false;
	}

	/*
	 * This method extracts the task index.
	 * 
	 * @param commandUtil {@code CommandUtils} and editTaskElements {@code ArrayList<String>}
	 * 
	 * @return {@code String} with task index removed.
	 * 			
	 * 
	 */
	private String extractTaskID(CommandUtils commandUtil, ArrayList<String> editTaskElements) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_EXTRACT_TASK_ID);
		String temp = "";
		
		if (editTaskElements.size() < 2) {
			return temp;
		}
		else if (!editTaskElements.get(NUM_FIRST_ELEMENT).startsWith(STRING_HASH_TAG)){
		
			commandUtil.setTaskID(editTaskElements.get(NUM_FIRST_ELEMENT));
			editTaskElements.remove(NUM_FIRST_ELEMENT);
			temp = toStringTaskElements(editTaskElements);
		}
		else if (editTaskElements.get(NUM_FIRST_ELEMENT).startsWith(STRING_HASH_TAG)) {
			
			temp = toStringTaskElements(editTaskElements);
		}
		
		return temp;
	}
	
	
	private String toStringTaskElements(ArrayList<String> taskNameArrayList) {
	
		String name = "";
		
		for (int i = 0; i < taskNameArrayList.size(); i++) {
			name += STRING_SPACING + taskNameArrayList.get(i); 
		}
		
		return name;
	}

}
```
###### /src/Parser/FlagAndCompleteParser.java
``` java
package Parser;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import Command.*;
import Logger.LoggerFile;

public class FlagAndCompleteParser {
	
	private static Logger logger;
	private FLAGANDCOMPLETE_TYPE _type;
	private ArrayList<Integer> taskIndex; 
	
	// Constants
	private static final String STRING_SPLITTER = "\\s+";
	private static final String KEYWORD_ALL = "all";
	private static final String KEYWORD_TO = " to ";
	private static final String KEYWORD_DASH = " - ";
	private static final String KEYWORD_SPACE = " "; 
	private static final String PUNCTUATION_REMOVER = "[:.,]";
	private static final int NUM_SINGLE_INDEX = 1;
	private static final int NUM_FIRST_ELEMENT = 0;
	private static final int NUM_TWO_ELEMENTS = 2;
	
	// Logging messages for proccesses.
	private static final String LOGGER_MESSAGE_PROCESS_FLAG_COMPLETE_COMMAND = "FlagAndComplete class: Entering FlagAndComplete class.";
	private static final String LOGGER_MESSAGE_EXIT_FLAG_COMPLETE_PARSER = "FlagAndComplete class: Exiting FlagAndComplete class.";
	private static final String LOGGER_MESSAGE_ANALYSE_FLAG_COMPLETE_TYPE = "FlagAndComplete class: Analysing FlagAndComplete type.";
	private static final String LOGGER_MESSAGE_PROCESS_SINGLE_FLAG_COMPLETE = "FlagAndComplete class: Process single input.";
	private static final String LOGGER_MESSAGE_PROCESS_MULTIPLE_FLAG_COMPLETE = "FlagAndComplete class: Process multiple inputs.";
	private static final String LOGGER_MESSAGE_PROCESS_RANGE_FLAG_COMPLETE = "FlagAndComplete class: Process range inputs.";
	private static final String LOGGER_MESSAGE_PROCESS_ALL_FLAG_COMPLETE = "FlagAndComplete class: Process all inputs.";
	private static final String LOGGER_MESSAGE_PROCESS_DETERMINE_FLAG_COMPLETE_METHOD = "FlagAndComplete class: Determine flag and complete method.";
	private static final String LOGGER_MESSAGE_CHECK_IF_SINGLE = "FlagAndComplete class: Check if single input.";
	private static final String LOGGER_MESSAGE_CHECK_IF_RANGE = "FlagAndComplete class: Check if range inputs.";
	private static final String LOGGER_MESSAGE_CHECK_IF_MULTIPLE = "FlagAndComplete class: Check if multiple inputs.";
	private static final String LOGGER_MESSAGE_CHECK_IF_ALL = "FlagAndComplete class: Check if all inputs.";
	private static final String LOGGER_MESSAGE_INVALID = "FlagAndComplete class: Invalid FlagAndComplete type.";
	
	public FlagAndCompleteParser() {
		
		this.taskIndex = new ArrayList<Integer>();
		logger = LoggerFile.getLogger();
	}

	/*
	 * This method process the flag and complete command.
	 * 
	 * @param commandUtil {@code CommandUtils} and ususerTaskIndexerInput {@code String}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	protected CommandUtils executeFlagCompleteParser(CommandUtils commandUtil, String userInput) {
		
		assert (userInput != null);
		logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_FLAG_COMPLETE_COMMAND);
		
		String[] str = userInput.trim().replaceAll(PUNCTUATION_REMOVER, KEYWORD_SPACE).toLowerCase().split(STRING_SPLITTER);
		commandUtil = determineFlagAndCompleteType(commandUtil, userInput.toLowerCase());
		_type = commandUtil.getFlagAndCompleteType();
		
		logger.log(Level.INFO, LOGGER_MESSAGE_EXIT_FLAG_COMPLETE_PARSER);
		return processFlagAndCompleteType(commandUtil, userInput, str);
	}
	
	/*
	 * This method process the flag and complete type".
	 * 
	 * @param commandUtil {@code CommandUtils}, userInput {@code String}
	 * 		  str {@code String[]}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	private CommandUtils processFlagAndCompleteType(CommandUtils commandUtil, String userInput, String[] str) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_ANALYSE_FLAG_COMPLETE_TYPE);
		
		switch (_type) {
		
			case SINGLE:
				logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_SINGLE_FLAG_COMPLETE);
				return parseSingle(commandUtil, str);
			
			case MULTIPLE:
				logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_MULTIPLE_FLAG_COMPLETE);
				return parseMultiple(commandUtil, str);
			
			case RANGE:
				logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_RANGE_FLAG_COMPLETE);
				return parseRange(commandUtil, userInput);
			
			case ALL:
				logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_ALL_FLAG_COMPLETE);
				break;
			
			default:
				break;
		}
		
		return commandUtil;
	}
	
	/*
	 * This method process a range of flag/complete inputs.
	 * 
	 * @param commandUtil {@code CommandUtils} and userInput {@code String}
	 *
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	private CommandUtils parseRange(CommandUtils commandUtil, String userInput) {
		
		if (userInput.contains(KEYWORD_DASH)) {
			userInput = userInput.replace(KEYWORD_DASH, KEYWORD_SPACE);
		}
		else if (userInput.contains(KEYWORD_TO)) {
			userInput = userInput.replace(KEYWORD_TO, KEYWORD_SPACE);
		}
		
		String[] temp = userInput.split(STRING_SPLITTER);
		
		if (temp.length == NUM_TWO_ELEMENTS) {
			for (int i = Integer.parseInt(temp[NUM_FIRST_ELEMENT]); i < Integer.parseInt(temp[1]) + 1; i++) {
				taskIndex.add(i);
			}
		}
		
		commandUtil.setTaskToFlagAndMark(taskIndex);
		return commandUtil;
	}

	/*
	 * This method process multiple flag/complete inputs.
	 * 
	 * @param commandUtil {@code CommandUtils} and userInput {@code String}
	 *
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	private CommandUtils parseMultiple(CommandUtils commandUtil, String[] str) {
		
		for (int i = 0; i < str.length; i++) {
			taskIndex.add(Integer.parseInt(str[i]));
		}
		
		commandUtil.setTaskToFlagAndMark(taskIndex);
		return commandUtil;
	}
	
	/*
	 * This method process single flag/complete input.
	 * 
	 * @param commandUtil {@code CommandUtils} and str {@code String[]}
	 *
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	private CommandUtils parseSingle(CommandUtils commandUtil, String[] str) {
		
		taskIndex.add(Integer.parseInt(str[NUM_FIRST_ELEMENT]));
		commandUtil.setTaskToFlagAndMark(taskIndex);
		
		return commandUtil;
	}

	/*
	 * This method determines the type of FlagAndComplete type. 
	 * 
	 * @param commandUtil {@code CommandUtils} and userInput {@code String}
	 *
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	private CommandUtils determineFlagAndCompleteType(CommandUtils commandUtil, String userInput) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_DETERMINE_FLAG_COMPLETE_METHOD);
		
		if (checkIfSingle(userInput)) {
			logger.log(Level.INFO, LOGGER_MESSAGE_CHECK_IF_SINGLE);
			commandUtil.setFlagCompleteType(FLAGANDCOMPLETE_TYPE.SINGLE);
		}
		else if (checkIfRange(userInput)) {
			logger.log(Level.INFO, LOGGER_MESSAGE_CHECK_IF_RANGE);
			commandUtil.setFlagCompleteType(FLAGANDCOMPLETE_TYPE.RANGE);
		}
		else if (checkIfMultiple(userInput)) {
			logger.log(Level.INFO, LOGGER_MESSAGE_CHECK_IF_MULTIPLE);
			commandUtil.setFlagCompleteType(FLAGANDCOMPLETE_TYPE.MULTIPLE);
		}
		else if (checkIfAll(userInput)) {
			logger.log(Level.INFO, LOGGER_MESSAGE_CHECK_IF_ALL);
			commandUtil.setFlagCompleteType(FLAGANDCOMPLETE_TYPE.ALL);
		}
		else {
			logger.log(Level.INFO, LOGGER_MESSAGE_INVALID);
			commandUtil.setFlagCompleteType(FLAGANDCOMPLETE_TYPE.INVALID);
		}
		
		return commandUtil;
	}

	/*
	 * This method checks if it is a flag/complete all type. 
	 * 
	 * @param userInput {@code String}
	 *
	 * @return {@code boolean}
	 * 			
	 * 
	 */
	private boolean checkIfAll(String userInput) {
		
		String[] temp = userInput.split(STRING_SPLITTER);
		
		return (userInput.toLowerCase().contains(KEYWORD_ALL) && 
				temp.length == NUM_SINGLE_INDEX) ? true: false;
	}

	/*
	 * This method checks if it is a flag/complete range type. 
	 * 
	 * @param userInput {@code String}
	 *
	 * @return {@code boolean}
	 * 			
	 * 
	 */
	
	private boolean checkIfRange(String userInput) {
		
		return (userInput.contains(KEYWORD_DASH) || (userInput.contains(KEYWORD_TO))) 
				? true : false;
	}

	/*
	 * This method checks if it is a flag/complete multiple type. 
	 * 
	 * @param userInput {@code String}
	 *
	 * @return {@code boolean}
	 * 			
	 * 
	 */
	
	private boolean checkIfMultiple(String userInput) {
		String[] str = userInput.replaceAll(PUNCTUATION_REMOVER, KEYWORD_SPACE).toLowerCase().split(STRING_SPLITTER);
		return (str.length > NUM_SINGLE_INDEX && !checkIfRange(userInput)) ? true : false;
	}
	
	/*
	 * This method checks if it is a flag/complete single type. 
	 * 
	 * @param userInput {@code String}
	 *
	 * @return {@code boolean}
	 * 			
	 * 
	 */
	
	private boolean checkIfSingle(String String) {
		String[] temp = String.split(STRING_SPLITTER);
		return (temp.length == NUM_SINGLE_INDEX && !temp[NUM_FIRST_ELEMENT].toLowerCase().contains(KEYWORD_ALL)) 
				? true : false;
	}
}
```
###### /src/Parser/FlexiCommand.java
``` java
package Parser;

import java.util.HashMap;
import Command.*;

/*
 *@author Pay Hao Jie
 *@Description: This class consolidates the possible inputs for a specific command 
 *				if the user happens to key in a different variation. 
 */

public class FlexiCommand {
	
	private static HashMap<String, COMMAND_TYPE> possibleCommands;
	
	public FlexiCommand() {
		possibleCommands = new HashMap<String, COMMAND_TYPE>();
		possibleCommands = initiateFlexiAddCommand();
		possibleCommands = initiateFlexiDeleteCommand();
		possibleCommands = initiateFlexiEditCommand();
		possibleCommands = initiateFlexiCompleteCommand();
		possibleCommands = initiateFlexiUndoCommand();
		possibleCommands = initiateFlexiRedoCommand();
		possibleCommands = initiateFlexiFlagCommand();
		possibleCommands = initiateFlexiUnflagCommand();
		possibleCommands = initiateFlexiTagCommand();
		possibleCommands = initiateFlexiUntagCommand();
		possibleCommands = initiateFlexiSearchCommand();
		possibleCommands = initiateFlexiSortCommand();
		possibleCommands = initiateFlexiHelpCommand();
		possibleCommands = initiateFlexiChangeDirectoryCommand();
		possibleCommands = initiateFlexiExitCommand();

	}
	
	public HashMap<String, COMMAND_TYPE> getKeywordsDataBase() {
		return possibleCommands;
	}
	
	private HashMap<String, COMMAND_TYPE> initiateFlexiAddCommand() {
		possibleCommands.put("add", COMMAND_TYPE.ADD);
		possibleCommands.put("+", COMMAND_TYPE.ADD);
		possibleCommands.put("ad", COMMAND_TYPE.ADD);
		possibleCommands.put("adds", COMMAND_TYPE.ADD);
		possibleCommands.put("a", COMMAND_TYPE.ADD);
		possibleCommands.put("create", COMMAND_TYPE.ADD);
		possibleCommands.put("creates", COMMAND_TYPE.ADD);
		possibleCommands.put("creat", COMMAND_TYPE.ADD);
		return possibleCommands;
	}

	private HashMap<String, COMMAND_TYPE> initiateFlexiDeleteCommand() {
		possibleCommands.put("d", COMMAND_TYPE.DELETE);
		possibleCommands.put("delete", COMMAND_TYPE.DELETE);
		possibleCommands.put("dlt", COMMAND_TYPE.DELETE);
		possibleCommands.put("del", COMMAND_TYPE.DELETE);
		possibleCommands.put("deletes", COMMAND_TYPE.DELETE);
		possibleCommands.put("remove", COMMAND_TYPE.DELETE);
		possibleCommands.put("rm", COMMAND_TYPE.DELETE);
		possibleCommands.put("r", COMMAND_TYPE.DELETE);
		return possibleCommands;
		
	}
	
	private HashMap<String, COMMAND_TYPE> initiateFlexiEditCommand() {
		possibleCommands.put("ed", COMMAND_TYPE.EDIT);
		possibleCommands.put("edit", COMMAND_TYPE.EDIT);
		possibleCommands.put("edits", COMMAND_TYPE.EDIT);
		possibleCommands.put("update", COMMAND_TYPE.EDIT);
		possibleCommands.put("updates", COMMAND_TYPE.EDIT);
		possibleCommands.put("change", COMMAND_TYPE.EDIT);
		possibleCommands.put("changes", COMMAND_TYPE.EDIT);
		return possibleCommands;
	}
	
	
	private HashMap<String, COMMAND_TYPE> initiateFlexiUndoCommand() {
		possibleCommands.put("undo", COMMAND_TYPE.UNDO);
		possibleCommands.put("back", COMMAND_TYPE.UNDO);
		possibleCommands.put("previous", COMMAND_TYPE.UNDO);
		possibleCommands.put("revert", COMMAND_TYPE.UNDO);
		possibleCommands.put("b", COMMAND_TYPE.UNDO);
		possibleCommands.put("goback", COMMAND_TYPE.UNDO);
		return possibleCommands;
	}
	
	private HashMap<String, COMMAND_TYPE> initiateFlexiCompleteCommand() {
		possibleCommands.put("complete", COMMAND_TYPE.COMPLETE);
		possibleCommands.put("completes", COMMAND_TYPE.COMPLETE);
		possibleCommands.put("done", COMMAND_TYPE.COMPLETE);
		possibleCommands.put("fin", COMMAND_TYPE.COMPLETE);
		possibleCommands.put("end", COMMAND_TYPE.COMPLETE);
		return possibleCommands;
	}
	
	private HashMap<String, COMMAND_TYPE> initiateFlexiRedoCommand() {
		possibleCommands.put("redo", COMMAND_TYPE.REDO);
		possibleCommands.put("redos", COMMAND_TYPE.REDO);
		return possibleCommands;
		
	}
	
	private HashMap<String, COMMAND_TYPE> initiateFlexiFlagCommand() {
		possibleCommands.put("flag", COMMAND_TYPE.FLAG);
		possibleCommands.put("flags", COMMAND_TYPE.FLAG);
		possibleCommands.put("important", COMMAND_TYPE.FLAG);
		possibleCommands.put("impt", COMMAND_TYPE.FLAG);
		possibleCommands.put("starred", COMMAND_TYPE.FLAG);
		possibleCommands.put("star", COMMAND_TYPE.FLAG);
		return possibleCommands;
		
	}
	
	private HashMap<String, COMMAND_TYPE> initiateFlexiUnflagCommand() {
		possibleCommands.put("unflag", COMMAND_TYPE.UNFLAG);
		possibleCommands.put("unflags", COMMAND_TYPE.UNFLAG);
		possibleCommands.put("unimportant", COMMAND_TYPE.UNFLAG);
		possibleCommands.put("unimpt", COMMAND_TYPE.UNFLAG);
		possibleCommands.put("unstarred", COMMAND_TYPE.UNFLAG);
		possibleCommands.put("unstar", COMMAND_TYPE.UNFLAG);
		return possibleCommands;
	}
	
	private HashMap<String, COMMAND_TYPE> initiateFlexiTagCommand() {
		possibleCommands.put("tag", COMMAND_TYPE.TAG);
		possibleCommands.put("cat", COMMAND_TYPE.TAG);
		possibleCommands.put("tags", COMMAND_TYPE.TAG);
		possibleCommands.put("category", COMMAND_TYPE.TAG);
		return possibleCommands;
		
	}
	
	private HashMap<String, COMMAND_TYPE> initiateFlexiUntagCommand() {
		possibleCommands.put("untag", COMMAND_TYPE.UNTAG);
		possibleCommands.put("untags", COMMAND_TYPE.UNTAG);
		return possibleCommands;
	}
	
	private HashMap<String, COMMAND_TYPE> initiateFlexiSortCommand() {
		possibleCommands.put("sort", COMMAND_TYPE.SORT);
		possibleCommands.put("arrange", COMMAND_TYPE.SORT);
		possibleCommands.put("sorts", COMMAND_TYPE.SORT);
		return possibleCommands;
		
	}
	
	private HashMap<String, COMMAND_TYPE> initiateFlexiSearchCommand() {
		possibleCommands.put("search", COMMAND_TYPE.SEARCH);
		possibleCommands.put("find", COMMAND_TYPE.SEARCH);
		possibleCommands.put("f", COMMAND_TYPE.SEARCH);
		return possibleCommands;
	}
	
	
	private HashMap<String, COMMAND_TYPE> initiateFlexiHelpCommand() {
		possibleCommands.put("help", COMMAND_TYPE.HELP);
		possibleCommands.put("helps", COMMAND_TYPE.HELP);
		possibleCommands.put("h", COMMAND_TYPE.HELP);
		possibleCommands.put("assist", COMMAND_TYPE.HELP);
		return possibleCommands;
	}
	private HashMap<String, COMMAND_TYPE> initiateFlexiChangeDirectoryCommand() {
		possibleCommands.put("cd", COMMAND_TYPE.CHANGE_DIRECTORY);
		possibleCommands.put("redirect", COMMAND_TYPE.CHANGE_DIRECTORY);
		return possibleCommands;
	}

	private HashMap<String, COMMAND_TYPE> initiateFlexiExitCommand() {
		possibleCommands.put("exit", COMMAND_TYPE.EXIT);
		possibleCommands.put("exits", COMMAND_TYPE.EXIT);
		possibleCommands.put("quit", COMMAND_TYPE.EXIT);
		possibleCommands.put("quits", COMMAND_TYPE.EXIT);
		possibleCommands.put("q", COMMAND_TYPE.EXIT);
		possibleCommands.put("q!", COMMAND_TYPE.EXIT);
		possibleCommands.put("terminate", COMMAND_TYPE.EXIT);
		return possibleCommands;
	}
	
}
```
###### /src/Parser/Parser.java
``` java
package Parser;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.logging.*;

import Command.*;
import Task.*;
import Logger.*;

public class Parser {

	private HashMap<String, COMMAND_TYPE> possibleCommandErrors;	
	private ArrayList<String> tags;
	private static Logger logger;
	
	protected TASK_TYPE taskType;
	protected COMMAND_TYPE command;
	protected String taskName;
	protected Date startTime;
	protected Date endTime;
	protected int taskID;
	protected String tag;
	private String _addCommand = "add ";
	protected boolean isImportant;
	private CommandUtils commandUtil;
	
	// Constants
	private final String SYMBOL_HASH_TAG = "#";
	private final String SYMBOL_DASH = "-";
	private final String SYMBOL_EXCLAMATION_MARK = "!";
	private final String SYMBOL_SPACING = " ";
	private final String SYMBOL_EMPTY = "";
	private final String STRING_SPLITTER = "\\s+";
	
	private final int POSITION_OF_TASK_CONTENT = 1;
	private final int POSITION_OF_COMMAND = 0;
	
	// Logging messages for processing commands.
	private final String LOGGER_MESSAGE_ADD_COMMAND = "Processing Add Command.";
	private final String LOGGER_MESSAGE_DELETE_COMMAND = "Processing Delete Command.";
	private final String LOGGER_MESSAGE_EDIT_COMMAND = "Processing Edit Command.";
	private final String LOGGER_MESSAGE_COMPLETE_COMMAND = "Processing Complete Command.";
	private final String LOGGER_MESSAGE_FLAG_COMMAND = "Processing Flag Command.";
	private final String LOGGER_MESSAGE_UNFLAG_COMMAND = "Processing Unflag Command.";
	private final String LOGGER_MESSAGE_TAG_COMMAND = "Processing Tag Command.";
	private final String LOGGER_MESSAGE_UNTAG_COMMAND = "Processing Untag Command.";
	private final String LOGGER_MESSAGE_SEARCH_COMMAND = "Processing Search Command.";
	private final String LOGGER_MESSAGE_SORT_COMMAND = "Processing Sort Command.";
	
	// Logging messages for processing methods.
	private final String LOGGER_MESSAGE_EXECUTE_COMMAND = "Parser Class: Processing user input in executeCommand method.";
	private final String LOGGER_MESSAGE_VERIFY_ADD_COMMAND = "Parser Class: Processing user input in verifyIfAddCommand method.";
	private final String LOGGER_MESSAGE_PROCESS_USER_INPUT = "Parser Class: Processing user input in processUserInput method.";
	private final String LOGGER_MESSAGE_CHECK_IF_VALID_INPUT = "Parser Class: Processing user input in checkIfValidUserInput method.";
	private final String LOGGER_MESSAGE_DETERMINE_COMMAND_TYPE = "Parser Class: Processing user input in determineCommandType method.";
	private final String LOGGER_MESSAGE_GET_USER_COMMAND = "Parser Class: Processing user input in getUserCommand method.";
	private final String LOGGER_MESSAGE_GET_USER_INPUT = "Parser Class: Processing user input in getUserInput method.";
	private final String LOGGER_MESSAGE_CHECK_IMPORTANCE = "Parser Class: Processing user input in checkTaskImportance method.";
	private final String LOGGER_MESSAGE_EXTRACT_TAG = "Parser Class: Processing user input in extractTag method.";
	private final String LOGGER_MESSAGE_EXIT_PARSER_CLASS = "Parser Class: Existing Parser Class.";
	
	public Parser() {
		
		possibleCommandErrors = new HashMap<String, COMMAND_TYPE>();
		logger = LoggerFile.getLogger();
	}
	
	/*
	 * This method analyses the command type of an input and extract the
	 * information of the input.
	 * 
	 * @param commandUtil {@code CommandUtils} and userInput {@code String}
	 * 
	 * @return {@code CommandUtils} with attributes of the command set to 
	 * CommandUtils object.
	 * 
	 */
	public CommandUtils executeCommand(CommandUtils commandUtil, String userInput) {
		
		
		assert userInput.length() > 0;
		logger.log(Level.INFO, LOGGER_MESSAGE_EXECUTE_COMMAND);
		
		this.commandUtil = commandUtil;
		checkIfValidUserInput(userInput.trim());
		String command = getUserCommand(userInput);
		COMMAND_TYPE commandType = determineCommandType(command, userInput.trim());
		userInput = appendsAddToCommand(userInput, commandType);
		
		switch (commandType) {
			
			case ADD:
				logger.log(Level.INFO, LOGGER_MESSAGE_ADD_COMMAND);
				userInput = processUserInput(commandUtil, userInput);
				AddParser addParser = new AddParser();
				return addParser.executeAddParser(commandUtil, userInput.trim());
				
			case DELETE:
				logger.log(Level.INFO, LOGGER_MESSAGE_DELETE_COMMAND);
				userInput = getUserInputContent(userInput);
				DeleteParser deleteParser = new DeleteParser();
				return deleteParser.executeDeleteParser(commandUtil, userInput);
				
			case EDIT:
				logger.log(Level.INFO, LOGGER_MESSAGE_EDIT_COMMAND);
				userInput = getUserInputContent(userInput);
				EditParser editParser = new EditParser();
				return editParser.executeEditParser(commandUtil, userInput);
				
			case COMPLETE:
				logger.log(Level.INFO, LOGGER_MESSAGE_COMPLETE_COMMAND);
				userInput = getUserInputContent(userInput);
				FlagAndCompleteParser completeParser = new FlagAndCompleteParser();
				return completeParser.executeFlagCompleteParser(commandUtil, userInput);
				
			case FLAG:
				logger.log(Level.INFO, LOGGER_MESSAGE_FLAG_COMMAND);
				userInput = getUserInputContent(userInput);
				FlagAndCompleteParser flagParser = new FlagAndCompleteParser();
				return flagParser.executeFlagCompleteParser(commandUtil, userInput);
				
			case UNFLAG:
				logger.log(Level.INFO, LOGGER_MESSAGE_UNFLAG_COMMAND);
				userInput = getUserInputContent(userInput);
				FlagAndCompleteParser unflagParser = new FlagAndCompleteParser();
				return unflagParser.executeFlagCompleteParser(commandUtil, userInput);
				
			case TAG:
				logger.log(Level.INFO, LOGGER_MESSAGE_TAG_COMMAND);
				userInput = processUserInput(commandUtil, userInput);
				commandUtil.setTaskID(userInput.trim());
				break;
				
			case UNTAG:
				logger.log(Level.INFO, LOGGER_MESSAGE_UNTAG_COMMAND);
				userInput = processUserInput(commandUtil, userInput);
				commandUtil.setTaskID(userInput.trim());
				break;
				
			case SEARCH:
				logger.log(Level.INFO, LOGGER_MESSAGE_SEARCH_COMMAND);
				userInput = getUserInputContent(userInput);
				SearchParser search = new SearchParser();
				return search.executeSearchParser(commandUtil, userInput);
				
			case SORT:
				logger.log(Level.INFO, LOGGER_MESSAGE_SORT_COMMAND);
				userInput = getUserInputContent(userInput);
				SortParser sort = new SortParser();
				return sort.determineSortType(commandUtil, userInput);
				
			default:
				break;
		}
		
		logger.log(Level.INFO, LOGGER_MESSAGE_EXIT_PARSER_CLASS);
		return commandUtil;
	}
	
	/*
	 * This method appends a string Add to every add command.
	 * 
	 * @param userInput {@code String} and commandType {@code COMMAND_TYPE}
	 * 
	 * @return {@code String} with Add string appended in front.
	 * 			
	 * 
	 */
	private String appendsAddToCommand(String userInput, COMMAND_TYPE commandType) {
		
		assert (userInput != null);
		logger.log(Level.INFO, LOGGER_MESSAGE_VERIFY_ADD_COMMAND);	
		
		if (commandType == COMMAND_TYPE.ADD && !userInput.toLowerCase().contains(_addCommand)) {
			userInput = _addCommand + SYMBOL_SPACING + userInput;
		}
		
		return userInput;
	}
	
	/*
	 * This method extract taggings and flag from userInput
	 * 
	 * @param userInput {@code String} and commandUtil {@code CommandUtils}
	 * 
	 * @return {@code String} with tags and flag removed from userInput
	 * 			
	 * 
	 */
	private String processUserInput(CommandUtils commandUtil, String userInput) {
		
		assert (userInput != null);
		logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_USER_INPUT);
		
		String userTask = getUserInputContent(userInput);
		userTask = checkTaskImportance(commandUtil, userTask);
	
		return extractTag(commandUtil, userTask);	
	}
	
	/*
	 * This method checks if user has entered a valid input.
	 * Set COMMAND_TYPE as invalid if input is empty.
	 * 
	 */

	private void checkIfValidUserInput(String userInput) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_CHECK_IF_VALID_INPUT);

		if (userInput.replaceAll(SYMBOL_SPACING, SYMBOL_EMPTY).length() == 0) {
			commandUtil.setCommandType(COMMAND_TYPE.INVALID);
		}
		
	}
	
	/*
	 * This method analyse the command type that a user has entered.
	 * 
	 * @param userInput {@code String}
	 * 
	 * @return {@code COMMAND_TYPE}
	 * 			
	 * 
	 */

	public COMMAND_TYPE determineCommandType(String commandType, String userInput) {
		
		assert (commandType != null);
		logger.log(Level.INFO, LOGGER_MESSAGE_DETERMINE_COMMAND_TYPE);
		
		FlexiCommand flexiCommand = new FlexiCommand();
		possibleCommandErrors = flexiCommand.getKeywordsDataBase();

		if (possibleCommandErrors.containsKey(commandType) ) {
			this.command = possibleCommandErrors.get(commandType);
		}
		else if (userInput.replaceAll(SYMBOL_SPACING, SYMBOL_EMPTY).length() == 0) {
			this.command = COMMAND_TYPE.INVALID;
		}
		else {
			this.command = COMMAND_TYPE.ADD;
		}
		
		commandUtil.setCommandType(this.command);
		return command;
	}
	
	/*
	 * This method extract the command type that a user has entered.
	 * 
	 * @param userInput {@code String}
	 * 
	 * @return {@code COMMAND_TYPE} with task content removed.
	 * 			
	 * 
	 */

	private String getUserCommand(String userInput) {
		
		assert (userInput != null);
		logger.log(Level.INFO, LOGGER_MESSAGE_GET_USER_COMMAND);
		String[] temp = userInput.split(STRING_SPLITTER, 2);
		
		return temp[POSITION_OF_COMMAND].toLowerCase();
	}
	
	/*
	 * This method analyses the command type that a user has entered.
	 * 
	 * @param userInput {@code String}
	 * 
	 * @return {@code String} with COMMAND_TYPE extracted.
	 * 			
	 * 
	 */

	private String getUserInputContent(String userInput) {
		
		assert (userInput != null);
		logger.log(Level.INFO, LOGGER_MESSAGE_GET_USER_INPUT);
		String[] temp = userInput.split(STRING_SPLITTER, 2);
		
		return temp[POSITION_OF_TASK_CONTENT];
	}
	
	/*
	 * This method checks and extracts the flag from userInput.
	 * 
	 * @param commandUtil {@code CommandUtils} and userInput {@code String}
	 * 
	 * @return {@code String} with flagging removed from userInput.
	 * 			
	 */
	
	private String checkTaskImportance(CommandUtils commandUtil, String userInput) {
		
		assert (userInput != null);
		logger.log(Level.INFO, LOGGER_MESSAGE_CHECK_IMPORTANCE);
		
		String[] temp = userInput.split(STRING_SPLITTER);
		int positionOfImportance = temp.length;
		
		if (temp[positionOfImportance - 1].contains(SYMBOL_EXCLAMATION_MARK) 
			&& temp[positionOfImportance - 1].length() == 1) {
			
			userInput = userInput.replace(SYMBOL_EXCLAMATION_MARK, SYMBOL_EMPTY);
			commandUtil.setTaskImportance(true);
		
		}
		else {
			commandUtil.setTaskImportance(false);
		}
		
		return userInput;
	}
	
	/*
	 * This method checks and extracts tag(s) from userInput.
	 * 
	 * @param commandUtil {@code CommandUtils} and user {@code String}
	 * 
	 * @return {@code String} with tag(s) removed from userInput.
	 * 			
	 */
	
	private String extractTag(CommandUtils commandUtil, String userInput) {
		
		assert (userInput != null);
		logger.log(Level.INFO, LOGGER_MESSAGE_EXTRACT_TAG);
		
		tags = new ArrayList<String>();
		String[] str = userInput.split(STRING_SPLITTER);
		String temp = "";
		
		for (int i = 0; i < str.length; i++) {
			
			if (str[i].contains(SYMBOL_HASH_TAG) && !str[i].contains(SYMBOL_DASH) 
				&& str[i].length() > 1) {
				
				tags.add(str[i].replaceFirst(SYMBOL_HASH_TAG, SYMBOL_EMPTY).trim());
				str[i] = SYMBOL_EMPTY;
			
			}
			else {
				temp += str[i] + SYMBOL_SPACING;
			}
		}
		
		commandUtil.setTaskTag(tags);
		return temp.trim();
	}

}
```
###### /src/Parser/SearchParser.java
``` java

package Parser;

import java.util.Date;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import Command.*;
import Logger.LoggerFile;

import org.ocpsoft.prettytime.nlp.PrettyTimeParser;

public class SearchParser {
	
	private String tag;
	private SEARCH_TYPE searchType;
	private static Logger logger;
	
	// Constants
	private static final String PREPOSITION_BY = "by";
	private static final String PREPOSITION_BY_WITH_SPACE = "by";
	private static final String STRING_HASH_TAG = "#";
	private static final String STRING_SPLITTER = "\\s+";
	private static final String STRING_EMPTY = "";
	
	// Logging Message for processes
	private static final String LOGGER_MESSAGE_PROCESS_SEARCH_COMMAND = "SearchParser Class: Processing Search Command.";
	private static final String LOGGER_MESSAGE_EXIT_SEARCH_PARSER_CLASS = "SearchParser Class: Exiting SearchParser class." ;
	private static final String LOGGER_MESSAGE_ANALYSING_SEARCH_TYPE = "SearchParser Class: Analysing search type.";
	private static final String LOGGER_MESSAGE_PROCESS_SEARCH_DATE = "SearchParser Class: Processing search date.";
	private static final String LOGGER_MESSAGE_PROCESS_SEARCH_TAG = "SearchParser Class: Processing search tag.";
	private static final String LOGGER_MESSAGE_PROCESS_INVALID = "SearchParser Class: Process is invalid.";
	private static final String LOGGER_MESSAGE_PROCESS_DETERMINE_SEARCH_TYPE = "SearchParser Class: Determining serch type.";
	private static final String LOGGER_MESSAGE_PROCESS_IS_SEARCH_TASK = "SearchParser Class: Checking if search task type.";
	private static final String LOGGER_MESSAGE_PROCESS_IS_SEARCH_DATE = "SearchParser Class: Checking if search date type.";
	private static final String LOGGER_MESSAGE_PROCESS_IS_SEARCH_TAG = "SearchParser Class: Checking if search tag type.";
	private static final String LOGGER_MESSAGE_PROCESS_REMOVE_BY = "SearchParser Class: Removing \"by\".";

	public SearchParser() {
		logger = LoggerFile.getLogger();
	}

	/*
	 * This method process the Search command.
	 * 
	 * @param commandUtil {@code CommandUtils} and userTask {@code String}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	protected CommandUtils executeSearchParser(CommandUtils commandUtil, String userTask) {
	
		assert (userTask != null);
		logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_SEARCH_COMMAND);
		
		userTask = removeBy(userTask);
		commandUtil = determineSearchType(commandUtil, userTask);
		searchType = commandUtil.getSearchType();
		
		logger.log(Level.INFO, LOGGER_MESSAGE_EXIT_SEARCH_PARSER_CLASS);
		return analyseSearchType(commandUtil, userTask);
	}
	
	/*
	 * This method process the search type accordingly.
	 * 
	 * @param commandUtil {@code CommandUtils} and userTask {@code String}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */

	private CommandUtils analyseSearchType(CommandUtils commandUtil, String userTask) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_ANALYSING_SEARCH_TYPE);
		
		switch(searchType) {
			
		case BY_DATE:
			logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_SEARCH_DATE);
			return processByDate(commandUtil, userTask);
		
		case BY_TASK:
			logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_SEARCH_DATE);
			return processByTask(commandUtil, userTask);
		
		case BY_TAG:
			logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_SEARCH_TAG);
			return processByTag(commandUtil, userTask);
		
		default:
			logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_INVALID);
			commandUtil.setSearchType(SEARCH_TYPE.INVALID);
			break;
		}
		
		return commandUtil;
	}

	/*
	 * This method processes the search task type.
	 * 
	 * @param commandUtil {@code CommandUtils} and userTask {@code String}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	private CommandUtils processByTask(CommandUtils commandUtil, String userTask) {
		commandUtil.setSearchByTask(userTask.trim());
		return commandUtil;
	}

	/*
	 * This method processes the search tag type.
	 * 
	 * @param commandUtil {@code CommandUtils} and userTask {@code String}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	private CommandUtils processByTag(CommandUtils commandUtil, String userTask) {
		
		tag = userTask.trim().substring(1, userTask.length());
		commandUtil.setSearchByTag(tag);
		
		return commandUtil;
	}

	/*
	 * This method processes the search date type.
	 * 
	 * @param commandUtil {@code CommandUtils} and userTask {@code String}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	private CommandUtils processByDate(CommandUtils commandUtil, String userTask) {
		
		List<Date> dates = new PrettyTimeParser().parse(userTask);
		commandUtil.setSearchByDate(dates.get(0));
		
		return commandUtil;
	}

	/*
	 * This method analyses the search type.
	 * 
	 * @param commandUtil {@code CommandUtils} and userTask {@code String}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	private CommandUtils determineSearchType(CommandUtils commandUtil, String userTask) {
		
		logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_DETERMINE_SEARCH_TYPE);
		
		if (isSearchDate(userTask)) {
			logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_IS_SEARCH_DATE);
			commandUtil.setSearchType(SEARCH_TYPE.BY_DATE);
		}
		else if (isSearchTaskName(userTask)) {
			logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_IS_SEARCH_TASK);
			commandUtil.setSearchType(SEARCH_TYPE.BY_TASK);
		}
		else if (isSearchTag(userTask)) {
			logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_IS_SEARCH_TAG);
			commandUtil.setSearchType(SEARCH_TYPE.BY_TAG);
		}
		else {
			logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_INVALID);
			commandUtil.setSearchType(SEARCH_TYPE.INVALID);
		}
		return commandUtil;
	}

	/*
	 * This method checks if search tag type.
	 * 
	 * @param userTask {@code String}
	 * 
	 * @return {@code boolean}
	 * 			
	 * 
	 */
	private boolean isSearchTag(String userTask) {
		assert userTask.split(STRING_SPLITTER).length == 1;
		return (userTask.startsWith(STRING_HASH_TAG)) ? true : false;
	}

	/*
	 * This method checks if search date type.
	 * 
	 * @param userTask {@code String}
	 * 
	 * @return {@code boolean}
	 * 			
	 * 
	 */
	private boolean isSearchDate(String userTask) {
		List<Date> dates = new PrettyTimeParser().parse(userTask);
		return (dates.size() != 0) ? true : false;
	}

	/*
	 * This method checks if search task name type.
	 * 
	 * @param userTask {@code String}
	 * 
	 * @return {@code boolean}
	 * 			
	 * 
	 */
	private boolean isSearchTaskName(String userTask) {
		return (!userTask.startsWith(STRING_HASH_TAG)) ? true : false;
	}

	/*
	 * This method removes the "by" after search command
	 * 
	 * @param userTask {@code String}
	 * 
	 * @return {@code String} with the "by after search command removed.
	 * 			
	 * 
	 */
	private String removeBy(String userTask) {
		
		assert (userTask.length() > 0);
		logger.log(Level.INFO, LOGGER_MESSAGE_PROCESS_REMOVE_BY);
		
		String[] str = userTask.toLowerCase().split(STRING_SPLITTER);
		
		if (str[0].contains(PREPOSITION_BY)) {
			userTask.replace(PREPOSITION_BY_WITH_SPACE, STRING_EMPTY);
		}
		
		return userTask;
	}
		
}
```
###### /src/Parser/SortParser.java
``` java

package Parser;

import java.util.logging.Level;
import java.util.logging.Logger;

import Command.*;
import Logger.*;

public class SortParser {
	
	private static Logger logger;
	private static final String ALPHABETICAL_ORDER = "abc";
	private static final String NUMERICAL_ORDER = "123";
	private static final String REVERSE_ALPHABETICAL_ORDER = "cba";
	private static final String REVERSE_NUMERICAL_ORDER = "321";
	private static final String DATE_ORDER = "date";
	private static final String PREPOSITION_BY = "by";
	private static final int POSITION_OF_INPUT  = 0;
	private static final String STRING_SPLITTER = "\\s+";
	private static final String STRING_EMPTY = "";
	
	// Variable
	private String[] stringSplit;
	
	// Logging messages for methods
	private static final String LOGGER_MESSAGE_DETERMINE_SORT_TYPE = "SortParser Class: Processing user input in determineSortType method.";
	private static final String LOGGER_MESSAGE_IS_REVERSE_ALPHABETICAL = "SortParser Class: Processing user input in isSortByReverseAlphabetical method.";
	private static final String LOGGER_MESSAGE_IS_ALPHABETICAL = "SortParser Class: Processing user input in isSortByAlphabetical method.";
	private static final String LOGGER_MESSAGE_IS_BY_DATE = "SortParser Class: Processing user input in isSortByDate method.";
	private static final String LOGGER_MESSAGE_REMOVE_BY = "SortParser Class: Processing user input in removeBy method.";
	private static final String LOGGER_MESSAGE_IS_SORT_DATE = "SortParser Class: Sort type is BY_DATE.";
	private static final String LOGGER_MESSAGE_IS_SORT_ASCENDING = "SortParser Class: Sort type is BY_ASCENDING.";
	private static final String LOGGER_MESSAGE_IS_SORT_DESCENDING = "SortParser Class: Sort type is BY_DESCENDING.";
	private static final String LOGGER_MESSAGE_IS_INVALID_SORT = "SortParser Class: Sort type is INVALID.";
	
			
	public SortParser() {
		logger = LoggerFile.getLogger();
	}
	
	/*
	 * This method process the Sort command.
	 * 
	 * @param commandUtil {@code CommandUtils} and userTask {@code String}
	 * 
	 * @return {@code CommandUtils}
	 * 			
	 * 
	 */
	protected CommandUtils determineSortType(CommandUtils commandUtil, String userTask) {
		
		assert (userTask != null);
		logger.log(Level.INFO, LOGGER_MESSAGE_DETERMINE_SORT_TYPE);
		
		userTask = removeBy(userTask.toLowerCase());
		
		if (isSortByDate(userTask)) {
			logger.log(Level.INFO, LOGGER_MESSAGE_IS_SORT_DATE);
			commandUtil.setSortType(SORT_TYPE.BY_DATE);
		}
		else if (isSortByAlphabetical(userTask)) {
			logger.log(Level.INFO, LOGGER_MESSAGE_IS_SORT_ASCENDING);
			commandUtil.setSortType(SORT_TYPE.BY_ASCENDING);
		}
		else if (isSortByReverseAlphabetical(userTask)) {
			logger.log(Level.INFO, LOGGER_MESSAGE_IS_SORT_DESCENDING);
			commandUtil.setSortType(SORT_TYPE.BY_DESCENDING);
		}
		else {
			logger.log(Level.INFO, LOGGER_MESSAGE_IS_INVALID_SORT);
			commandUtil.setSortType(SORT_TYPE.INVALID);
		}
		return commandUtil;
	}
	
	/*
	 * This method checks if it is a sort by descending order type.
	 * 
	 * @param userTask {@code String}
	 * 
	 * @return {@code boolean}
	 * 			
	 * 
	 */
	private boolean isSortByReverseAlphabetical(String userTask) {
		
		assert(userTask != null);
		logger.log(Level.INFO, LOGGER_MESSAGE_IS_REVERSE_ALPHABETICAL);
		
		stringSplit = userTask.toLowerCase().split(STRING_SPLITTER);
		
		return (stringSplit[POSITION_OF_INPUT].trim().contains(REVERSE_ALPHABETICAL_ORDER) ||
				stringSplit[POSITION_OF_INPUT].trim().contains(REVERSE_NUMERICAL_ORDER)) ? true : false;
	
	}
	
	/*
	 * This method checks if it is a sort by ascending order type.
	 * 
	 * @param userTask {@code String}
	 * 
	 * @return {@code boolean}
	 * 			
	 * 
	 */
	private boolean isSortByAlphabetical(String userTask) {
		
		assert(userTask != null);
		logger.log(Level.INFO, LOGGER_MESSAGE_IS_ALPHABETICAL);
		
		stringSplit = userTask.toLowerCase().split(STRING_SPLITTER);
		
		return (stringSplit[POSITION_OF_INPUT].trim().contains(ALPHABETICAL_ORDER) ||
				stringSplit[POSITION_OF_INPUT].trim().contains(NUMERICAL_ORDER)) ? true : false;
	
	}

	/*
	 * This method checks if it is a sort by date type.
	 * 
	 * @param userTask {@code String}
	 * 
	 * @return {@code boolean}
	 * 			
	 * 
	 */
	private boolean isSortByDate(String userTask) {
		
		assert(userTask != null);
		logger.log(Level.INFO, LOGGER_MESSAGE_IS_BY_DATE);
		
		stringSplit = userTask.toLowerCase().split(STRING_SPLITTER);
		
		return (stringSplit[POSITION_OF_INPUT].trim().contains(DATE_ORDER)) ? true : false;
	
	}
	
	/*
	 * This method removes the "by" after sort command
	 * 
	 * @param userTask {@code String}
	 * 
	 * @return {@code String} with the "by after sort command removed.
	 * 			
	 * 
	 */
	private String removeBy(String userTask) {
		
		assert(userTask != null);
		logger.log(Level.INFO, LOGGER_MESSAGE_REMOVE_BY);
		
		stringSplit = userTask.toLowerCase().split(STRING_SPLITTER);
		
		if (stringSplit[POSITION_OF_INPUT].contains(PREPOSITION_BY)) {
			userTask = userTask.replace(PREPOSITION_BY, STRING_EMPTY);
		}
		
		return userTask.trim();
	}
}
```
###### /src/Test/TestParser.java
``` java

package Test;

import static org.junit.Assert.assertEquals;

import org.junit.Test;
import java.text.SimpleDateFormat;
import java.util.Date;

import Command.*;
import Task.*;
import Parser.*;

public class TestParser {
	CommandUtils cu = new CommandUtils();
	Parser parser = new Parser();
	
	@Test
	/**
	 * Test to ensure that the user inputs has been correctly assigned 
	 * the task type.
	 * The title should be the whole user input.
	 * 
	 */
	public void testTaskType() throws Exception {
		
		cu = parser.executeCommand(cu, "drive by the beach");
		assertEquals(TASK_TYPE.FLOATING, cu.getType());
		
		cu = parser.executeCommand(cu, "submit assignment 1 by tomorrow");
		assertEquals(TASK_TYPE.DEADLINED, cu.getType());
		
		cu = parser.executeCommand(cu, "take a walk by the beach by 2359hrs");
		assertEquals(TASK_TYPE.DEADLINED, cu.getType());
		
		cu = parser.executeCommand(cu, "submit assignment 1 by tomorrow by 2359hrs");
		assertEquals(TASK_TYPE.DEADLINED, cu.getType());
		
		cu = parser.executeCommand(cu, "fetch my brother at 2pm");
		assertEquals(TASK_TYPE.DEADLINED, cu.getType());
		
		cu = parser.executeCommand(cu, "attend soc camp from 27/6/2016 to 28/6/2016");
		assertEquals(TASK_TYPE.EVENT, cu.getType());
		
		cu = parser.executeCommand(cu, "jog from school to home");
		assertEquals(TASK_TYPE.FLOATING, cu.getType());
		
		cu = parser.executeCommand(cu,"bake matcha cheesecake at home");
		assertEquals(TASK_TYPE.FLOATING, cu.getType());
		
		cu = parser.executeCommand(cu, "piano tuning on sunday");
		assertEquals(TASK_TYPE.DEADLINED, cu.getType());
		
		cu = parser.executeCommand(cu,"build sandcastle on the road");
		assertEquals(TASK_TYPE.FLOATING, cu.getType());
		
		cu = parser.executeCommand(cu, "dancing on the dancefloor at zouk");
		assertEquals(TASK_TYPE.FLOATING, cu.getType());
		
	}
	
	@Test
	public void testCommandType() throws Exception {
		
		cu = parser.executeCommand(cu, "        ");
		assertEquals(COMMAND_TYPE.INVALID, cu.getCommandType());
		
	}
	
	@Test
	public void testFloating() throws Exception{
		cu = parser.executeCommand(cu,"Drive by the beach");
		assertEquals(COMMAND_TYPE.ADD, cu.getCommandType());
		assertEquals("Drive by the beach", cu.getName());
		assertEquals(TASK_TYPE.FLOATING, cu.getType());
		
		cu = parser.executeCommand(cu,"fetch my brother from school");
		assertEquals("fetch my brother from school", cu.getName());
		assertEquals(TASK_TYPE.FLOATING, cu.getType());
		
		cu = parser.executeCommand(cu,"Pick Sheena from the school");
		assertEquals("Pick Sheena from the school", cu.getName());
		assertEquals(TASK_TYPE.FLOATING, cu.getType());
		
		cu = parser.executeCommand(cu,"Set up PA system on the stage with Hannah");
		assertEquals("Set up PA system on the stage with Hannah", cu.getName());
		assertEquals(TASK_TYPE.FLOATING, cu.getType());
		
		cu = parser.executeCommand(cu,"lie on the bed with Hannah at hotel 81");
		assertEquals("lie on the bed with Hannah at hotel 81", cu.getName());
		assertEquals(TASK_TYPE.FLOATING, cu.getType());
		
		cu = parser.executeCommand(cu,"brush my teeth before bedtime");
		assertEquals("brush my teeth before bedtime", cu.getName());
		assertEquals(TASK_TYPE.FLOATING, cu.getType());
		
		cu = parser.executeCommand(cu,"cycle with jun lem from sengkang to nus");
		assertEquals("cycle with jun lem from sengkang to nus", cu.getName());
		assertEquals(TASK_TYPE.FLOATING, cu.getType());
	
		cu = parser.executeCommand(cu,"buy slurpee from \"7/11\"");
		assertEquals("buy slurpee from \"7/11\"", cu.getName());
		assertEquals(TASK_TYPE.FLOATING, cu.getType());
		
		cu = parser.executeCommand(cu,"dance on the dancefloor at zouk");
		assertEquals("dance on the dancefloor at zouk", cu.getName());
		assertEquals(TASK_TYPE.FLOATING, cu.getType());
		
		cu = parser.executeCommand(cu,"Meet Carousell buyer on the ground floor at block 2359");
		assertEquals("Meet Carousell buyer on the ground floor at block 2359", cu.getName());
		assertEquals(TASK_TYPE.FLOATING, cu.getType());
		
		cu = parser.executeCommand(cu,"Watch \"the day after tomorrow\"");
		assertEquals("Watch \"the day after tomorrow\"", cu.getName());
		assertEquals(TASK_TYPE.FLOATING, cu.getType());
		
		cu = parser.executeCommand(cu,"Submit CS2103T Assignment 1 to Prof Henry Chia at his office");
		assertEquals("Submit CS2103T Assignment 1 to Prof Henry Chia at his office", cu.getName());
		assertEquals(TASK_TYPE.FLOATING, cu.getType());
		
		cu = parser.executeCommand(cu,"Keep the dough in the dark before it gets mouldy");
		assertEquals("Keep the dough in the dark before it gets mouldy", cu.getName());
		assertEquals(TASK_TYPE.FLOATING, cu.getType());
		
		cu = parser.executeCommand(cu,"read my favourite storybook by \"June\" Tan");
		assertEquals("read my favourite storybook by \"June\" Tan", cu.getName());
		assertEquals(TASK_TYPE.FLOATING, cu.getType());
		
		cu = parser.executeCommand(cu,"     buy mee sua from cofeeshop     ");
		assertEquals("buy mee sua from cofeeshop", cu.getName());
		assertEquals(TASK_TYPE.FLOATING, cu.getType());
		
	}

	
	@Test
	
	public void testDeadlined() throws Exception {
		
		SimpleDateFormat dateFormat = new SimpleDateFormat("EEE MMM d HH:mm:ss Z yyyy");
		String endDate = "";
		
		/*
		 * When user enters an invalid date in the month of Feb, the program will
		 * return the difference of input date with the last day of Feb and add it
		 * to the last day of Feb.
		 * 
		 * Example: Last day of Feb 2017 is 28th Feb 2017.
		 * 			31st Feb - 28th Feb = 3 days.
		 * 			28th Feb + 3 days = 3rd March 2017.
		 */
		cu = parser.executeCommand(cu, "drive baby howard home by 31st Feb 2017");
		assertEquals(COMMAND_TYPE.ADD, cu.getCommandType());
		endDate = "Fri Mar 03 18:00:00 SGT 2017";
		Date expectedStart = dateFormat.parse(endDate);
		assertEquals(expectedStart, cu.getEndTime());
		assertEquals("drive baby howard home", cu.getName());
		assertEquals(TASK_TYPE.DEADLINED, cu.getType());
		
		cu = parser.executeCommand(cu, "Deadline for COE bidding at 2400hrs on 27/06/2016");
		endDate = "Tue Jun 28 00:00:00 SGT 2016";
		expectedStart = dateFormat.parse(endDate);
		assertEquals(expectedStart, cu.getEndTime());
		assertEquals("Deadline for COE bidding", cu.getName());
		assertEquals(TASK_TYPE.DEADLINED, cu.getType());
		
		cu = parser.executeCommand(cu, "watch movie on 0 feb 2017");
		endDate = "Wed Feb 01 00:00:00 SGT 2017";
		expectedStart = dateFormat.parse(endDate);
		assertEquals(expectedStart, cu.getEndTime());
		assertEquals("watch movie", cu.getName());
		assertEquals(TASK_TYPE.DEADLINED, cu.getType());
		
		cu = parser.executeCommand(cu, "submit assignment 1 before 1st June at 2359hrs");
		endDate = "Wed Jun 01 23:59:00 SGT 2016";
		expectedStart = dateFormat.parse(endDate);
		assertEquals(expectedStart, cu.getEndTime());
		assertEquals("submit assignment 1", cu.getName());
		assertEquals(TASK_TYPE.DEADLINED, cu.getType());
		
		cu = parser.executeCommand(cu,"Take out my meringue cake from the oven at 13.45pm");
		endDate = "Mon Apr 11 13:45:00 SGT 2016";
		expectedStart = dateFormat.parse(endDate);
		assertEquals(expectedStart, cu.getEndTime());
		assertEquals("Take out my meringue cake from the oven", cu.getName());
		assertEquals(TASK_TYPE.DEADLINED, cu.getType());
		
		cu = parser.executeCommand(cu,"Check in luggage at counter 7 at 23.45am");
		endDate = "Mon Apr 11 23:45:00 SGT 2016";
		expectedStart = dateFormat.parse(endDate);
		assertEquals(expectedStart, cu.getEndTime());
		assertEquals("Check in luggage at counter 7", cu.getName());
		assertEquals(TASK_TYPE.DEADLINED, cu.getType());
		
		cu = parser.executeCommand(cu, "meeting with boss on 27 MAY 2016 at 2pm");
		endDate = "Fri May 27 14:00:00 SGT 2016";
		expectedStart = dateFormat.parse(endDate);
		assertEquals(expectedStart, cu.getEndTime());
		assertEquals("meeting with boss", cu.getName());
		assertEquals(TASK_TYPE.DEADLINED, cu.getType());
	
		cu = parser.executeCommand(cu, "Purchase rugby 7 tickets on 28/07");
		assertEquals(COMMAND_TYPE.ADD, cu.getCommandType());
		endDate = "Thu Jul 28 18:00:00 SGT 2016";
		expectedStart = dateFormat.parse(endDate);
		assertEquals(expectedStart, cu.getEndTime());
		assertEquals("Purchase rugby 7 tickets", cu.getName());
		assertEquals(TASK_TYPE.DEADLINED, cu.getType());

	}

	@Test
	public void testEvent() throws Exception {
		
		SimpleDateFormat dateFormat = new SimpleDateFormat("EEE MMM d HH:mm:ss Z yyyy");
		String startDate = "";
		String endDate = "";
		Date expectedStart;
		Date expectedEnd; 
		
		cu = parser.executeCommand(cu, "Hackathon from 01.05.2016 2pm to 05.05.2016 7pm");
		assertEquals(COMMAND_TYPE.ADD, cu.getCommandType());
		startDate = "Sun May 01 14:00:00 SGT 2016";
		endDate = "Thu May 05 19:00:00 SGT 2016";
		expectedStart = dateFormat.parse(startDate);
		expectedEnd = dateFormat.parse(endDate);
		assertEquals(expectedStart, cu.getStartTime());
		assertEquals(expectedEnd, cu.getEndTime());
		assertEquals("Hackathon", cu.getName());
		assertEquals(TASK_TYPE.EVENT, cu.getType());
		
		cu = parser.executeCommand(cu, "serve the nation from 24th Aug 2017 to 29th Oct 2017");
		startDate = "Thu Aug 24 00:00:00 SGT 2017";
		endDate = "Sun Oct 29 18:00:00 SGT 2017";
		expectedStart = dateFormat.parse(startDate);
		expectedEnd = dateFormat.parse(endDate);
		assertEquals(expectedStart, cu.getStartTime());
		assertEquals(expectedEnd, cu.getEndTime());
		assertEquals("serve the nation", cu.getName());
		assertEquals(TASK_TYPE.EVENT, cu.getType());
		
		cu = parser.executeCommand(cu, "Dinner by the beach before sunset at Jumbo from 09/09/16 to 09.09.16");
		startDate = "Fri Sep 09 00:00:00 SGT 2016";
		endDate = "Fri Sep 09 18:00:00 SGT 2016";
		expectedStart = dateFormat.parse(startDate);
		expectedEnd = dateFormat.parse(endDate);
		assertEquals(expectedStart, cu.getStartTime());
		assertEquals(expectedEnd, cu.getEndTime());
		assertEquals("Dinner by the beach before sunset at Jumbo", cu.getName());
		assertEquals(TASK_TYPE.EVENT, cu.getType());
		
		cu = parser.executeCommand(cu, "Employees review at 7pm from 05/12/16 to 06.12.16");
		startDate = "Mon Dec 05 19:00:00 SGT 2016";
		endDate = "Tue Dec 06 19:00:00 SGT 2016";
		expectedStart = dateFormat.parse(startDate);
		expectedEnd = dateFormat.parse(endDate);
		assertEquals(expectedStart, cu.getStartTime());
		assertEquals(expectedEnd, cu.getEndTime());
		assertEquals("Employees review", cu.getName());
		assertEquals(TASK_TYPE.EVENT, cu.getType());
		

	}
	
	@Test
	public void testComplete() {
		cu = parser.executeCommand(cu, "complete 1");
		assertEquals(COMMAND_TYPE.COMPLETE, cu.getCommandType());
		assertEquals(FLAGANDCOMPLETE_TYPE.SINGLE, cu.getFlagAndCompleteType());
		
		cu = parser.executeCommand(cu,"complete 1, 6, 9");
		assertEquals(FLAGANDCOMPLETE_TYPE.MULTIPLE, cu.getFlagAndCompleteType());
		
		cu = parser.executeCommand(cu,"complete 1 to 9");
		assertEquals(FLAGANDCOMPLETE_TYPE.RANGE, cu.getFlagAndCompleteType());
		
		cu = parser.executeCommand(cu,"complete 1 - 100");
		assertEquals(FLAGANDCOMPLETE_TYPE.RANGE, cu.getFlagAndCompleteType());
		
		cu = parser.executeCommand(cu,"complete all");
		assertEquals(FLAGANDCOMPLETE_TYPE.ALL, cu.getFlagAndCompleteType());

	}

	@Test
	public void testFlag() {

		cu = parser.executeCommand(cu,"flag 1");
		assertEquals(COMMAND_TYPE.FLAG, cu.getCommandType());
		assertEquals(FLAGANDCOMPLETE_TYPE.SINGLE, cu.getFlagAndCompleteType());
		
		cu = parser.executeCommand(cu, "flag 1, 6, 9");
		assertEquals(FLAGANDCOMPLETE_TYPE.MULTIPLE, cu.getFlagAndCompleteType());
		
		cu = parser.executeCommand(cu, "flag 1 to 9");
		assertEquals(FLAGANDCOMPLETE_TYPE.RANGE, cu.getFlagAndCompleteType());
		
		cu = parser.executeCommand(cu, "flag all");
		assertEquals(FLAGANDCOMPLETE_TYPE.ALL, cu.getFlagAndCompleteType());
		
		cu = parser.executeCommand(cu,"Meet Mr Norman for Advertising Pitch !");
		assertEquals(true, cu.getImportance());
		
		cu = parser.executeCommand(cu,"I love you!!!!");
		assertEquals(false, cu.getImportance());

	}
	
	@Test
	public void testDelete() {

		cu = parser.executeCommand(cu,"delete 123");
		assertEquals(COMMAND_TYPE.DELETE, cu.getCommandType());
		Integer single_delete = 123;
		assertEquals(DELETE_TYPE.SINGLE_INDEX, cu.getDeleteType());
		assertEquals( single_delete, cu.getIndexToDelete().get(0));
		
		cu = parser.executeCommand(cu,"delete 1, 6, 9");
		Integer delete1 = 1;
		Integer delete2 = 6;
		Integer delete3 = 9;
		assertEquals(DELETE_TYPE.MULTIPLE_INDEXES, cu.getDeleteType());
		assertEquals(delete1, cu.getIndexToDelete().get(0));
		assertEquals(delete2, cu.getIndexToDelete().get(1));
		assertEquals(delete3, cu.getIndexToDelete().get(2));
		
		cu = parser.executeCommand(cu,"delete 1 to 4");
		assertEquals(COMMAND_TYPE.DELETE, cu.getCommandType());
		delete1 = 1;
		delete2 = 2;
		delete3 = 3;
		Integer delete4 = 4;
		assertEquals(DELETE_TYPE.RANGE_INDEXES, cu.getDeleteType());
		assertEquals(delete1, cu.getIndexToDelete().get(0));
		assertEquals(delete2, cu.getIndexToDelete().get(1));
		assertEquals(delete3, cu.getIndexToDelete().get(2));
		assertEquals(delete4, cu.getIndexToDelete().get(3));
		
		cu = parser.executeCommand(cu,"delete all");
		assertEquals(COMMAND_TYPE.DELETE, cu.getCommandType());
		assertEquals(DELETE_TYPE.ALL_INDEXES, cu.getDeleteType());
		
		cu = parser.executeCommand(cu,"delete all tags");
		assertEquals(COMMAND_TYPE.DELETE, cu.getCommandType());
		assertEquals(DELETE_TYPE.ALL_TAGS, cu.getDeleteType());
		
		cu = parser.executeCommand(cu,"delete #nus");
		assertEquals(COMMAND_TYPE.DELETE, cu.getCommandType());
		String single_tag = "nus";
		assertEquals(DELETE_TYPE.SINGLE_TAG, cu.getDeleteType());
		assertEquals( single_tag, cu.getTagToDelete().get(0));

		cu = parser.executeCommand(cu,"delete #nus #singapore #SoC");
		String tag1 = "nus";
		String tag2 = "singapore";
		String tag3 = "SoC";
		assertEquals(DELETE_TYPE.MULTIPLE_TAGS, cu.getDeleteType());
		assertEquals(COMMAND_TYPE.DELETE, cu.getCommandType());
		assertEquals(tag1, cu.getTagToDelete().get(0));
		assertEquals(tag2, cu.getTagToDelete().get(1));
		assertEquals(tag3, cu.getTagToDelete().get(2));
		
		cu = parser.executeCommand(cu,"delete #11-11");
		assertEquals(COMMAND_TYPE.DELETE, cu.getCommandType());
		assertEquals(DELETE_TYPE.INVALID, cu.getDeleteType());
		
		cu = parser.executeCommand(cu,"delete #hello #11-11 #adele ");
		assertEquals(COMMAND_TYPE.DELETE, cu.getCommandType());
		assertEquals(DELETE_TYPE.MULTIPLE_TAGS, cu.getDeleteType());
		assertEquals("hello", cu.getTagToDelete().get(0));
		assertEquals("adele", cu.getTagToDelete().get(1));
		
		cu = parser.executeCommand(cu,"delete 1 start date");
		assertEquals(COMMAND_TYPE.DELETE, cu.getCommandType());
		assertEquals(DELETE_TYPE.START_DATE, cu.getDeleteType());
		
		cu = parser.executeCommand(cu,"delete 10 end date");
		assertEquals(COMMAND_TYPE.DELETE, cu.getCommandType());
		assertEquals(DELETE_TYPE.END_DATE, cu.getDeleteType());
		
		
	}
	
	@Test
	public void testEdit() throws Exception {
		SimpleDateFormat dateFormat = new SimpleDateFormat("EEE MMM d HH:mm:ss Z yyyy");
		
		cu = parser.executeCommand(cu, "edit 2 meet Hannah at Chong Pang");
		assertEquals(COMMAND_TYPE.EDIT, cu.getCommandType());
		int taskID = 2;
		assertEquals(EDIT_TYPE.TASK_NAME, cu.getEditType());
		assertEquals("meet Hannah at Chong Pang", cu.getName());
		assertEquals(taskID, cu.getTaskID());
		
		cu = parser.executeCommand(cu,"edit 4 from 5th May 2016 2359hrs");
		assertEquals(COMMAND_TYPE.EDIT, cu.getCommandType());
		taskID = 4;
		String str = "Thu May 05 23:59:00 SGT 2016";
		Date startTime = dateFormat.parse(str);
		assertEquals(EDIT_TYPE.START_TIME, cu.getEditType());
		assertEquals(taskID, cu.getTaskID());
		assertEquals(startTime, cu.getStartTime());
		
		cu = parser.executeCommand(cu, "edit 2 to 5th Nov 2016 2359hrs");
		assertEquals(COMMAND_TYPE.EDIT, cu.getCommandType());
		taskID = 2;
		str = "Sat Nov 05 23:59:00 SGT 2016";
		Date endTime = dateFormat.parse(str);
		assertEquals(EDIT_TYPE.END_TIME, cu.getEditType());
		assertEquals(taskID, cu.getTaskID());
		assertEquals(endTime, cu.getEndTime());
		
		cu = parser.executeCommand(cu, "edit 4 by 5th May 2016 2359hrs");
		assertEquals(COMMAND_TYPE.EDIT, cu.getCommandType());
		taskID = 4;
		str = "Thu May 05 23:59:00 SGT 2016";
		endTime = dateFormat.parse(str);
		assertEquals(EDIT_TYPE.DEADLINED, cu.getEditType());
		assertEquals(taskID, cu.getTaskID());
		assertEquals(startTime, cu.getEndTime());
		
/*		cu = parser.executeCommand(cu, "edit 10 from 5th Nov 2016 2359hrs to 12th Dec 2016");
		assertEquals(COMMAND_TYPE.EDIT, cu.getCommandType());
		taskID = 10;
		str = "Sat Nov 05 23:59:00 SGT 2016";
		startTime = dateFormat.parse(str);
		String str2 = "Mon Dec 12 23:59:00 SGT 2016";
		endTime = dateFormat.parse(str2);
		assertEquals(EDIT_TYPE.EVENT_TIME, cu.getEditType());
		assertEquals(taskID, cu.getTaskID());
		assertEquals(startTime, cu.getStartTime());
		assertEquals(endTime, cu.getEndTime());
	*/	
		cu = parser.executeCommand(cu, "edit #Singapore to #Melbourne");
		assertEquals(COMMAND_TYPE.EDIT, cu.getCommandType());
		String oldTag = "Singapore";
		String newTag = "Melbourne";
		assertEquals(EDIT_TYPE.TAG, cu.getEditType());
		assertEquals(oldTag, cu.getOldTag());
		assertEquals(newTag, cu.getTag().get(0));
		
		cu = parser.executeCommand(cu, "edit 123 Meet Hao Jie tomorrow");
		taskID = 123;
		assertEquals(COMMAND_TYPE.EDIT, cu.getCommandType());
		assertEquals(EDIT_TYPE.DEADLINED, cu.getEditType());
		assertEquals(taskID, cu.getTaskID());
		assertEquals("Meet Hao Jie", cu.getName());
		
		cu = parser.executeCommand(cu, "edit 923 4.36pm submit V0.5 proposal");
		taskID = 923;
		assertEquals(COMMAND_TYPE.EDIT, cu.getCommandType());
		assertEquals(EDIT_TYPE.DEADLINED, cu.getEditType());
		assertEquals(taskID, cu.getTaskID());
		assertEquals("submit V0.5 proposal", cu.getName());
	
		cu = parser.executeCommand(cu, "edit 01 study by the beach on monday at school");
		taskID = 1;
		assertEquals(COMMAND_TYPE.EDIT, cu.getCommandType());
		assertEquals(EDIT_TYPE.DEADLINED, cu.getEditType());
		assertEquals(taskID, cu.getTaskID());
		assertEquals("study by the beach at school", cu.getName());
	
	}
	
	@Test
	public void testSearch() throws Exception {

		cu = parser.executeCommand(cu, "search #Assignment");
		assertEquals(COMMAND_TYPE.SEARCH, cu.getCommandType());
		assertEquals(SEARCH_TYPE.BY_TAG, cu.getSearchType());
		assertEquals("Assignment", cu.getSearchByTag());
		
		cu = parser.executeCommand(cu, "search CS2103T");
		assertEquals(COMMAND_TYPE.SEARCH, cu.getCommandType());
		assertEquals(SEARCH_TYPE.BY_TASK, cu.getSearchType());
		assertEquals("CS2103T", cu.getSearchByTask());
		
		cu = parser.executeCommand(cu, "search 17/07/2016");
		assertEquals(COMMAND_TYPE.SEARCH, cu.getCommandType());
		assertEquals(SEARCH_TYPE.BY_DATE, cu.getSearchType());
	}
	
	@Test
	public void testSort() throws Exception {

		cu = parser.executeCommand(cu, "sort by abc");
		assertEquals(COMMAND_TYPE.SORT, cu.getCommandType());
		assertEquals(SORT_TYPE.BY_ASCENDING, cu.getSortType());
		
		cu = parser.executeCommand(cu, "sort by ABC");
		assertEquals(COMMAND_TYPE.SORT, cu.getCommandType());
		assertEquals(SORT_TYPE.BY_ASCENDING, cu.getSortType());
		
		cu = parser.executeCommand(cu, "sort by cba");
		assertEquals(COMMAND_TYPE.SORT, cu.getCommandType());
		assertEquals(SORT_TYPE.BY_DESCENDING, cu.getSortType());
		
		cu = parser.executeCommand(cu, "sort by CBA");
		assertEquals(COMMAND_TYPE.SORT, cu.getCommandType());
		assertEquals(SORT_TYPE.BY_DESCENDING, cu.getSortType());
		
		cu = parser.executeCommand(cu, "sort by date");
		assertEquals(COMMAND_TYPE.SORT, cu.getCommandType());
		assertEquals(SORT_TYPE.BY_DATE, cu.getSortType());
		
		cu = parser.executeCommand(cu, "sort by 123");
		assertEquals(COMMAND_TYPE.SORT, cu.getCommandType());
		assertEquals(SORT_TYPE.BY_ASCENDING, cu.getSortType());
		
		cu = parser.executeCommand(cu, "sort by 321");
		assertEquals(COMMAND_TYPE.SORT, cu.getCommandType());
		assertEquals(SORT_TYPE.BY_DESCENDING, cu.getSortType());
	}
	
	@Test
	public void testTag() throws Exception {
		int index = 1;
		cu = parser.executeCommand(cu, "tag 1 #HomeAlone");
		assertEquals(COMMAND_TYPE.TAG, cu.getCommandType());
		assertEquals(index, cu.getTaskID());
		assertEquals("HomeAlone", cu.getTag().get(0));
		
		cu = parser.executeCommand(cu, "tag 123 #This #is #HOME #truLy #SG50");
		index = 123;
		assertEquals(COMMAND_TYPE.TAG, cu.getCommandType());
		assertEquals(index, cu.getTaskID());
		assertEquals("This", cu.getTag().get(0));
		assertEquals("is", cu.getTag().get(1));
		assertEquals("HOME", cu.getTag().get(2));
		assertEquals("truLy", cu.getTag().get(3));
		assertEquals("SG50", cu.getTag().get(4));
		
		cu = parser.executeCommand(cu, "Procurement meeting at seminar room #Logistic #Planning");
		assertEquals(COMMAND_TYPE.ADD, cu.getCommandType());
		assertEquals("Procurement meeting at seminar room", cu.getName());
		assertEquals("Logistic", cu.getTag().get(0));
		assertEquals("Planning", cu.getTag().get(1));
		
		cu = parser.executeCommand(cu, "#dance #crewz Final rehearsal");
		assertEquals(COMMAND_TYPE.ADD, cu.getCommandType());
		assertEquals("Final rehearsal", cu.getName());
		assertEquals("dance", cu.getTag().get(0));
		assertEquals("crewz", cu.getTag().get(1));
		
		cu = parser.executeCommand(cu, "distribute 1000 flyers #Work to block 2359 #10-11");
		assertEquals(COMMAND_TYPE.ADD, cu.getCommandType());
		assertEquals("distribute 1000 flyers to block 2359 #10-11", cu.getName());
		assertEquals("Work", cu.getTag().get(0));
		
		cu = parser.executeCommand(cu, "Visit grandma #family # love");
		assertEquals(COMMAND_TYPE.ADD, cu.getCommandType());
		assertEquals("Visit grandma # love", cu.getName());
		assertEquals("family", cu.getTag().get(0));
		
		cu = parser.executeCommand(cu, "Just want to have fun at the playground #####7#####");
		assertEquals(COMMAND_TYPE.ADD, cu.getCommandType());
		assertEquals("Just want to have fun at the playground", cu.getName());
		assertEquals("####7#####", cu.getTag().get(0));
		
	}
	
	@Test
	public void testCommands() throws Exception {
		cu = parser.executeCommand(cu, "undo");
		assertEquals(COMMAND_TYPE.UNDO, cu.getCommandType());
		
		cu = parser.executeCommand(cu, "redo");
		assertEquals(COMMAND_TYPE.REDO, cu.getCommandType());
		
		cu = parser.executeCommand(cu, "RedIrEct");
		assertEquals(COMMAND_TYPE.CHANGE_DIRECTORY, cu.getCommandType());
		
		cu = parser.executeCommand(cu, "EXIT");
		assertEquals(COMMAND_TYPE.EXIT, cu.getCommandType());
		
		cu = parser.executeCommand(cu, "helP");
		assertEquals(COMMAND_TYPE.HELP, cu.getCommandType());
	}
}
```
